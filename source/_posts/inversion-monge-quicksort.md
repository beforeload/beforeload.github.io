title: inversion monge quicksort
date: 2013-05-17 22:44:25
tags: Algorithm
categories: Algorithm
---

##逆序对，Monge矩阵，快排优化——三数取中划分分析
### 题目

1. 第二章思考题2-4(逆序对)
2. 第四章思考题4-7(Monge矩阵)
3. 第七章思考题7-5(快排的三数取中划分分析)

### 2-4 逆序对

a)
{% gist 5599553 inversion.c %}

结果: 

(2,3)
(2,8)
(2,6)
(3,8)
(3,6)

b)

从1到n按倒序排列的数组含有最多的逆序对，
个数为(n-1)+(n-2)+...+1 = (n-1 + 1) * (n-1)/2 = n * (n-1)/2

c)

插入排序的运行时间与输入数组中逆序对的数量之间有怎样的关系?

当数组从小到大排序，插入排序算法复杂度最优为O(n),此时逆序对为0;

当数组从大到小排序，插入排序算法复杂度最坏情况，此时逆序对最多为n * (n-1)/2;

插入排序的过程如下：

```C
int insert_sort(void)
{
	int i, j, key;
	for (i = 1; i < N; i++) {
		key = arr[i];
		j = i;
		while (j > 0 && arr[j - 1] > key) {
			arr[j] = arr[j - 1];
			j--;
		}
	}
	for (i = 0; i < N; i++) {
		printf("%d ", arr[i]);
	}
}
```

每多一个逆序对存在，就需要多一次比较，运行时间增加。插入排序每次比较后交换元素都是减少一对逆序对，循环本身是对所有的逆序对排序的过程。   

d)
O(nlg(n))修改合并排序，确定n个元素的任意排列中逆序对的数目。

{% gist 5599593 inversion_d.c %}


### Monge矩阵

a)证明：当且仅当矩阵中所有2×2的矩阵都为Monge矩阵时，这个矩阵才为Monge矩阵。

先对行使用归纳法：假设i,k行j，l列矩阵为Monge矩阵，证明i,k+1行，j,l列矩阵为Monge矩阵即可

(1)已知i,k行j,l列为Monge矩阵即A[i,j]+A[k,l] <= A[i,l] + A[k,j]       
(2)假设A[k,j] + A[k+1,l] <= A[k+1,j] + A[k,l]       
(3)只需要证明i,k+1行j,l列的矩阵为Monge矩阵，      
由(1),(2)得A[i,j] + A[k+1,l] <= A[k,j] + A[k+1,l]                

对列用归纳法也是相同步骤，

已知A[i, j]+A[k, n] ≤ A[i, n]+A[k,j]                     
假设              
A[i, n]+A[k,n+1] ≤ A[i, n+1]+A[k,n]               
所以A[i, j]+A[k, n+1] ≤ A[i, n+1]+A[k, j]成立。                


行和列都满足归纳法，当`A[i,j]+A[i+1,j+1] <= A[i,j+1] + A[i+1,j]`时，整个矩阵为Monge矩阵。               

__"仅当"__这个条件用反正法可证。           

b) 利用a)的结论：`A[i,j] + A[i+1,j+1] <= A[i,j+1]+A[i+1,j]`              

很容易得到矩阵第二行第三列到第三行第四列的2×2矩阵不满足条件;                 
所以只需要将第二行第三列的16和第三行第三列的22交换即可。             

c)              
假设Monge矩阵中存在第x行和第x+1行，`f(x) > f(x+1)  (1 <= x < m)`               

已知`A[x,f(x+1)] + A[x+1, f(x)] <= A[x,f(x)] + A[x+1, f(x+1)]`                

又因为             


A[x,f(x)] < A[x, f(x+1)]        (1)                
A[x+1,f(x+1)] <= A[x+1, f(x)]   (2)


(1) + (2) 得：                 


A[x,f(x+1)] + A[x+1, f(x)] > A[x, f(x)] + A[x+1,f(x+1)]   (3)


根据a)结论，任意2×2矩阵都有

A[i,j] + A[i+1,j+1] <= A[i,j+1]+A[i+1,j]      (4)

(3) 和 (4)矛盾，假设不成立。              
由此可得：

f(1) <= f(2) <= ... <= f(m)            

d) 已知偶数行最左端最小值f(2), f(4), f(6), ... 
且f(2k) <= f(2k+1) <= f(2(k+1))

奇数行搜索一次，搜索范围为n列，偶数行重复计算两次


奇数行最左端最小值时间复杂度O(m/2+n)=O(m+n)
e)
由d)可得递归式：T(m) = T(m/2) + O(m+n)

递归运算结果：

T(m) = O(nlgm) + O(m+n)                   
     = O(nlgm + m + n)                
     = O(nlgm + m)              


### 快排中三数取中划分分析
{% img [inversion] //i.minus.com/i29Ufb20Oolkw.jpg %}
答案用图片显示，[图片在这里](//i.minus.com/i29Ufb20Oolkw.jpg) 

参考文章

1. [“三数取中“划分](//blog.csdn.net/zhanglei8893/article/details/6266915)

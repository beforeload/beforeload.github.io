title: Closure of JavaScript
date: 2014-01-03 22:17:17
categories: JavaScript
tags: JavaScript
---

# JavaScript 中的闭包

这篇文章写的较早，而且内容太水，建议不要浪费时间去阅读它。有时间我会重写一下。

<!-- more -->

最近被人问到JavaScript中闭包的作用，无意中回忆起很久之前实习面试的时候也被问过类似的问题，想起在写JS中遇到的一些习惯性的问题，写篇博客总结一下。


## 作用域

我感觉很多JS开发人员在对作用域的了解上都存在错误，虽然JavaScript是一种类C 的语言，但它并不支持块级作用域，块级作用域是定义在代码块中的变量在代码块执行结束后会被释放掉。

在JavaScript中，则是通过函数作用域的方式，函数中的参数和变量在函数外不可见，而函数内自由使用，即内部任意位置定义的变量在函数内部任何地方都可见，当然定义变量时，请用var。为了避免块级作用域可能产生的问题，可以在函数体的顶部声明函数可能用到的所有变量。这也是很多前端开发人员的一个很好的习惯。

## 闭包的产生

根据上面对作用域的描述，函数体内部可以访问外部函数的参数和变量（当然不包括this和arguments），这也叫做链式作用域(chain scope)。理解了作用域，闭包就变得很好理解了，我觉得可以这样简单的去理解它：一个定义在函数内部的函数，它可以访问创建时所处的上下文环境。这是最浅显的理解，当然它的作用远不止这些。

## 闭包的作用

一个闭包最重要的作用不仅仅是可以读取函数内部的变量，更让人惊喜的是，_只要内部函数需要_，这些变量的值在内存中会一直存在。可以在控制台中写个简单的例子来演示它：

```
var add
function a() {
    var x = 1
    add = function () {
        x += 1
    }

    function b() {
        console.log(x)
    }
    return b
}

var result = a()
result() // 1
add()
result() // 2
```

值得注意的是上面的例子中有两个闭包，add是一个匿名函数，也是一个闭包，它在函数外部定义，却在操作函数内部的变量。result是闭包b的函数，两次运行的值不同表示x值在内存中一直保存着，a调用结束后，x没有被回收。

如果上面例子理解有困难，那我们来简化它：

```
function a() {
    var x = 1
    function b() {
        x += 1
        console.log(x)
    }
    return b  // 注意，这个地方非常重要
}
var s = a()
s() // 2
s() // 3
```

现在只有一个闭包函数，这下子可以一眼看出来了吧。函数b嵌套在函数a内，函数a返回函数b。当函数b在函数a外部的一个变量引用时，就产生了闭包。

当然，由于长期保存在内存中不能释放，很多人也会遇到JavaScript内存泄露的问题(IE中)，这需要我们小心的使用闭包。有经验的前端工程师给出的建议是在推出函数之前，删除不使用的局部定义的变量。

## 理解闭包

```
var name = "The Window"
var object = {
    name: "My Object",   
    getNameFunc: function(){   
        return function(){   
            return this.name
        }   
    }   
}
console.log(object.getNameFunc()())
```

猜猜结果会是什么？
答案是："The Window"

很显然，闭包函数在``getNameFunc``函数外部被调用，那么``this``就不指向``object``对象，而指向了全局的``window``，所以最后的结果是``window.name``，也就是"The Window"

通过闭包，我们可以很显然的观察到函数的_定义_和_执行_过程。使用闭包，一方面可以保护函数内变量的安全，实现私有属性和私有方法的作用，另一方面可以在内存中保持一个变量。

## JS中的GC机制

这里延伸一点，解释一下为什么产生闭包时，内部函数会比外部函数拥有更长的生命周期。这是由JS中的GC机制决定的。

在JavaScript中，如果一个对象不再被引用，那么这个对象就被GC回收。如果两个对象相互引用，但不会被第三个对象引用时，这两个对象都会被回收。但是，如果函数a被b引用，b又被函数a外的c引用，这样函数a执行完之后，却不会被回收了。

写在最后的话：关于闭包的东西远远不止这些，使用方式也复杂多样，但是万变不离其宗，理解它的机制可以帮助我们写出更加高效优雅的代码。


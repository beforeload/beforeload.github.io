title: The Waterfall Flows Realization
date: 2014-09-03 08:09:39
tags:
---

# 瀑布流实现

__要点：__
1. 布局计算
2. 数据异步加载
3. resize
4. lazyload

<!-- more -->

## 1. 布局计算

一般来说，瀑布流实现会有两种布局定位方式，一种通过 float 浮动定位，
另一种通过绝对定位方式计算。前者的好处是不需要大量计算，缺点是坑多，
如浏览器兼容性问题，以及 resize 过程，窗口缩小时，
元素浮动也会存在一些问题。而后者的优势在于对浏览器兼容性较好，
但是需要经过大量计算得出元素摆放的位置。
推荐的实现方式是使用第二种方式。

在实际开发中，考虑到需要浏览器需要适配的尺寸有 980px，1200px，1420px 三种尺寸。
但每个元素摆放的位置其实是有固定模式的，即算法是固定的。980px 宽度下，
瀑布流是4列，1200以上是五列。 所以需要定义一个变量来计算每列的最大高度。
其实这个高度是与绝对定位 top 值有关，这也是我们需要定义和设置的值。
而对于列变化和尺寸的关系可以自己定义。

## 2. 数据异步加载

瀑布流多多少少都会和 Ajax 异步加载结合使用，在某种程度上，
也给人一种无限刷新的快感。实现起来也颇为容易，主要有三点，主要是事件绑定，
请求时机， 发送请求渲染 DOM。

首先是事件绑定，监听的是浏览器 scroll 事件，这里面有个IE 的坑。
在 IE 浏览器中，在滚动过程中会多次触发 scroll 事件。可以通过
setTimeout 来解决。         

其次是请求的时机，请求的时机可以提前，也提倡提前，也就是说，
数据返回后渲染dom的时机要滞后，这样会有一种更加流畅的感觉。       

最后是发送请求，我们知道 Ajax 请求是异步的，而 scroll 过程中可能
多次触发，多次发送请求，可以建一个对象，用 hash 的方法
缓存请求去避免多次发送同样的请求。请求结果同时缓存起来，
直接塞到 Model 里即可。

具体请求的时机可以结合 clientHeight，pageHeight，scrollHeight 几个参数来设定。

# 3. resize

resize 的过程需要重新计算布局，这个过程可能产生一些好玩的情况。
重新计算布局和第一点所说的一致，不再赘述。
现在主流的分辨率适配需要980px，1200px，1420px 三种宽度尺寸，
而 resize 过程中瀑布流可能导致列数切换以及列宽变换。

# 4. lazyload

瀑布流一般用途也多用于图片展示上，图片的 lazyload 是一个可以有很大优化的空间。
lazyload在瀑布流上需要考虑的地方其实蛮多的。 例如图片请求的时机，
请求和渲染 View 异步进行。

思考：

对于瀑布流的数据到 View 的渲染过程，我采用了简单的 Model 到 View 的绑定，
对于复杂的应用场景多多少少有点捉襟见肘。我的实现思路是：写一个计算器，
对于每个 Model 放置的位置，直接计算后把结果存在 Model 中，Model 由于存放
过多的数据多多少少显得臃肿，但是好处是对 View 的渲染过程变得容易，以及对
resize 和 scroll 事件的处理也只需要把 Model 丢到计算器中重新计算，
并重用计算结果 Model 到 View 的绘制过程。

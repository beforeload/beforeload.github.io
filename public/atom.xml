<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[beforeload]]></title>
  <subtitle><![CDATA[对编程世界充满激情的少年]]></subtitle>
  <link href="http://beforeload.github.io/atom.xml" rel="self"/>
  <link href="http://beforeload.github.io"/>
  <updated>2014-04-15T16:50:02.677Z</updated>
  <id>http://beforeload.github.io/</id>
  <author>
    <name><![CDATA[beforeload]]></name>
    <email><![CDATA[fe.daniel91@gmail.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[What is Inheritance in JavaScript]]></title>
    <link href="http://beforeload.github.io/2014/04/13/what-is-inheritance-in-javascript/"/>
    <id>http://beforeload.github.io/2014/04/13/what-is-inheritance-in-javascript/</id>
    <published>2014-04-13T10:20:55.000Z</published>
    <updated>2014-04-15T16:49:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="理解JavaScript中的继承">理解JavaScript中的继承</h1>
<p>什么是继承？简而言之，父亲和儿子，儿子对父亲有继承关系。一句话能说明的关系在JavaScript中，使用起来并不容易。</p>
<p>从以下几个方面理解JavaScript的继承：</p>
<ol>
<li>类，对象和原型</li>
<li>类的定义</li>
<li>原型继承</li>
<li>构造函数继承</li>
<li>封装构造函数继承</li>
<li>复制继承</li>
</ol>
<a id="more"></a>

<h2 id="类，对象和原型">类，对象和原型</h2>
<p>JavaScript中继承机制其实一点都不复杂，JavaScript是基于对象的弱类型语言，以对象为基础，以函数为模型，以原型为继承机制。<br>对JavaScript的继承的理解，不能像Java或者其他语言的类继承一样去理解，而要理解原型继承。</p>
<p>首先理解原型。字面上理解，prototype是类的原型。作为构造函数的属性，一个对象拥有的原始的属性和方法都在prototype中。<br>也可以这样理解，对于守财奴的藏宝库，重要的宝贝都放在里面。prototype就相当于这样的一个藏宝室。<br>所以我们可以把prototype理解成一个数据集合，理解成一个指向宝藏的指针。</p>
<p>类是对象的模型化，而对象则是类和实例的关系演化，守财奴的父亲拥有一大笔财产（类是模型），他的每个儿子都对他的财产有继承权（对象继承）。<br>所以对于构造类（父亲）实例化的构造实例（儿子），构造实例（儿子）的原型对象（Prototype）指向了构造类（父亲）的原型属性（prototype）。</p>
<p>在JavaScript中没有传统意义上的类，而类的思想是用函数来模拟和表达。在控制台中可以体验一下下面的代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">P</span><span class="params">(x)</span> {</span>
    <span class="keyword">this</span>.x = x;
}

P.prototype.x = <span class="number">1</span>; <span class="comment">// 这里会被上面的属性x覆盖</span>
<span class="keyword">var</span> s = <span class="keyword">new</span> P(<span class="number">10</span>);
<span class="keyword">var</span> s1 = <span class="keyword">new</span> P();
alert(s.x);  <span class="comment">// 10</span>
alert(s1.x);  <span class="comment">// undefined</span>
</pre></td></tr></table></figure>

<p>对象查询属性的顺序是最优先查询本地属性，如果没有查询对象本身的原型属性。因此，<br>虽然通过prototype设置了属性x的值，但是由于构造函数的原型属性和本地属性同名了，所以本地属性覆盖了原型属性。</p>
<p>JavaScript是动态的语言，设置原型的值会影响所有的实例。所以对上面的代码可以这样修改一下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">P</span><span class="params">(x)</span>{</span>      <span class="comment">//构造方法</span>
    <span class="keyword">if</span>(x) {
        <span class="keyword">this</span>.x = x;
    }
}

P.prototype.x = <span class="number">1</span>;
<span class="keyword">var</span> s = <span class="keyword">new</span> P();
alert(s.x);   <span class="comment">// 1</span>
<span class="keyword">var</span> s1 = <span class="keyword">new</span> P(<span class="number">10</span>);
alert(s1.x);  <span class="comment">// 10</span>
</pre></td></tr></table></figure>

<p>关于prototype属性的应用还有很多方面，比如说数据备份，设置只读属性，批量复制等，这里不一一赘述。</p>
<p>在JavaScript每个object都会有prototype属性，prototype指向另外的一个object对象。<br>通过上面的例子，我们可以知道，当我们需要读取一个object中某个属性x的时候，JavaScript引擎先查找这个object本身是否存在属性x。<br>如果不存在，才会查找这个object的prototype中是否存在属性x。</p>
<p>当我们new一个对象时，会给这个对象设置prototype属性，这个属性值来自它的构造函数的prototype属性值。<br>所有函数在定义时，就自动创建和初始化了prototype属性。这个prototype属性指向只包含constructor属性的对象，而constructor属性指向function本身。<br>因此，每一个object都会有一个constructor属性。</p>
<p>下面详细讲解以下类的定义的几种方式。</p>
<h2 id="类的定义">类的定义</h2>
<p>在JavaScript中，定义一个类通常有四种方式：</p>
<p>（1）工厂模式</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">/* 减少重复创建函数的开销 */</span>
<span class="keyword">var</span> method = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    alert(<span class="keyword">this</span>.name + <span class="string">':'</span> + <span class="keyword">this</span>.age);
}
<span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> {</span>
    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>();
    p.name = name;
    p.age = age;
    p.what = method;
    <span class="keyword">return</span> p; <span class="comment">// 初始化后的对象</span>
}
</pre></td></tr></table></figure>

<p>它是伪装的构造函数，不推荐使用。</p>
<p>(2) 构造函数模式</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> {</span>
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.age = age;
}

<span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'Daniel'</span>, <span class="number">22</span>);
</pre></td></tr></table></figure>

<p>上面this指向当前实例对象。如果构造函数返回对象，那么返回的对象会覆盖this的值。如下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> {</span>
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.age = age;
    <span class="keyword">return</span> <span class="keyword">this</span>;
}
</pre></td></tr></table></figure>

<p>(3) 原型模式</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> {</span>}
Person.prototype.name = <span class="string">'Daniel'</span>
Person.prototype.age = <span class="number">22</span>
Person.prototype.what = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    alert(<span class="keyword">this</span>.title + <span class="string">': '</span> + <span class="keyword">this</span>.age);
}
</pre></td></tr></table></figure>

<p>原型模式和构造函数模式的区别就是，构造函数模式的属性值是本地化的，而原型模式的属性值一旦更改，所有实例都会受到影响。</p>
<p>(4) 构造函数 + 原型模式</p>
<p>因为在原型模式不能轻易更改一个对象实例的属性值，而构造函数模式中又希望能够共享的使用一些属性和方法，所以引入“构造函数 + 原型模式”的混合设计。</p>
<p>如下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> {</span>    <span class="comment">// 构造函数的设计</span>
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.age = age;
}

Person.prototype.what = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>    <span class="comment">// 原型模式设计</span>
    alert(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.age);
}
</pre></td></tr></table></figure>

<p>如果我们希望遵循面向对象的设计原则，类成员都封装在类结构中，那么我们可以对构造函数原型模式进行加锁方式修改：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> {</span>
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.age = age;
    <span class="keyword">if</span>(<span class="keyword">typeof</span> Person.isLock == <span class="string">'undefined'</span>) {
        Person.prototype.what = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            alert(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.age);
        }
        Person.isLock = <span class="literal">true</span>;  <span class="comment">// 避免重复创建</span>
    }
}
</pre></td></tr></table></figure>

<h2 id="原型继承">原型继承</h2>
<p>原型继承可以完全从对象角度来考虑，而淡化类和实例。因为在原型继承中，不用去定义类，直接定义对象，当对象被其他对象引用时，形成了继承关系。<br>这种继承关系可以通过原型链来查找。其中引用对象称为原型对象（object prototype）。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">(x)</span> {</span>
    <span class="keyword">this</span>.x1 = x;
    <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.x1;
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(x)</span> {</span>
    <span class="keyword">this</span>.x2 = x;
    <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.x2 + <span class="keyword">this</span>.x2;
    }
}

B.prototype = <span class="keyword">new</span> A(<span class="number">1</span>);
<span class="function"><span class="keyword">function</span> <span class="title">C</span><span class="params">(x)</span> {</span>
    <span class="keyword">this</span>.x3 = x;
    <span class="keyword">this</span>.mul = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.x3 * <span class="keyword">this</span>.x3;
    }
}
C.prototype = <span class="keyword">new</span> B(<span class="number">2</span>);

<span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="number">2</span>);
<span class="keyword">var</span> c = <span class="keyword">new</span> C(<span class="number">3</span>);
alert(b.x1);    <span class="comment">// 1</span>
alert(c.x1);    <span class="comment">// 1</span>
alert(c.mul()); <span class="comment">// 9</span>
alert(c.add()); <span class="comment">// 4</span>
</pre></td></tr></table></figure>

<p>原型继承是直接复制已经存在的原型对象实现继承关系，基于原型而没有类的概念。不能很好的支持多参数和动态参数的父类。<br>结构简单，不支持多重继承，不够灵活，原型声明的同时需要实例化父类对象，限制了父类实例化的灵活性。</p>
<h2 id="构造函数继承">构造函数继承</h2>
<p>众所周知，构造函数也是函数的一种，只是比普通函数特殊一点而已。<br>当我们把构造函数A的方法赋值给构造函数B，然后调用该方法，构造函数A在B的内部执行，这时，B的内部就拥有了构造函数A中定义的属性和方法。<br>这种B继承A的实现过程跟传统的类继承还是非常相似的。所以在一些书籍中，这样的继承也成为类继承。</p>
<p>请看下面的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="comment">/* 构造函数A */</span>
<span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">(x)</span> {</span>
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        alert(<span class="keyword">this</span>.x);
    }
}

<span class="comment">/* 构造函数B */</span>
<span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(x, y)</span> {</span>
    <span class="keyword">this</span>.m = A;
    <span class="keyword">this</span>.m(x);
    <span class="keyword">delete</span> <span class="keyword">this</span>.m;
    <span class="keyword">this</span>.y = y;
    <span class="keyword">this</span>.call = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        alert(<span class="keyword">this</span>.y);
    }
}

<span class="comment">/* Tester */</span>
<span class="keyword">var</span> a = <span class="keyword">new</span> A(<span class="number">1</span>);
<span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="number">2</span>, <span class="number">3</span>);
a.say();    <span class="comment">// 1</span>
b.say();    <span class="comment">// 2 这里说明继承成功</span>
b.call();   <span class="comment">// 3</span>
</pre></td></tr></table></figure>

<p>上面的写法是不是感觉很难受，需要定义一个临时的方法<code>m()</code>，构造函数参数x传递给构造函数A，执行后又把临时方法删除，实在是有种卸磨杀驴的味道。<br>将父类的构造函数绑定在子类的构造函数上，可以使用call或者apply方法，推荐下面的写法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(x, y)</span> {</span>
    A.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.y = y;
    <span class="keyword">this</span>.call = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        alert(<span class="keyword">this</span>.y);
    }
}
</pre></td></tr></table></figure>

<p>即使这样优化后，还是欠妥，因为这样的构造函数继承中相互耦合性太高，不能适用复杂的编程中。</p>
<p>所以在构造函数继承中，引入prototype是很有必要的，请看下面的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">(x)</span>{</span>
    <span class="keyword">this</span>.x = x;
}

A.prototype.getx = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.x;
}

<span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(x, y)</span> {</span>
    <span class="keyword">this</span>.y = y;
    A.call(<span class="keyword">this</span>, x);
}

B.prototype = <span class="keyword">new</span> A();  <span class="comment">// 这个时候 B.prototype.constructor指向了A</span>
B.prototype.constructor = B;
B.prototype.gety = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.y;
}

<span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="number">2</span>, <span class="number">3</span>);
alert(b.getx());
alert(b.gety());
</pre></td></tr></table></figure>

<p>在原型继承中，在为B类的原型赋值为A类的实例前，所以定义的任何属性和方法都将会被覆盖。<br>扩展B类的原型方法，要在原型绑定之后，再定义扩展方法。</p>
<h2 id="封装构造函数继承">封装构造函数继承</h2>
<p>了解上面的构造函数继承后，我们可以定义一个形式如下的封装函数，帮助我们处理子类和超类的继承模式。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(Sub, Sup)</span> {</span> <span class="comment">// Sub 子类，Sup 超类</span>
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};    <span class="comment">// 这是一个空函数</span>
    F.prototype = Sup.prototype;
    Sub.prototype = <span class="keyword">new</span> F();
    Sub.prototype.constructor = Sub;
    Sub.sup = Sup.prototype;
    <span class="comment">/* 检测超类的原型构造器是否与Object的原型构造器发生耦合 */</span>
    <span class="keyword">if</span>(Sup.prototype.constructor == <span class="built_in">Object</span>.prototype.constructor) {
        Sup.prototype.constructor = Sup;
    }
}
</pre></td></tr></table></figure>

<p>值得注意的是上面的函数输入是子类和超类对象，没有输出。空函数F的作用是中转作用，F的原型为超类的原型，F的实例作为子类的原型。<br>这样做的好处是如果超类自身规模较大，直接实例化超类占用内存较大，对系统负荷较大。</p>
<p>对于上面封装函数的实现，我们可以用下面的例子来测试一下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">(x)</span> {</span>
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.x;
    }
}

A.prototype.double = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.x * <span class="number">2</span>;
}
A.prototype.mul = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.x * <span class="keyword">this</span>.x;
}

<span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(x)</span> {</span>
    A.call(<span class="keyword">this</span>, x);    <span class="comment">// 内部数据绑定</span>
}

extend(B, A);
<span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="number">2</span>);
alert(b.get());     <span class="comment">// 2</span>
alert(b.double());  <span class="comment">// 4</span>
alert(b.mul());     <span class="comment">// 4</span>
B.prototype.double = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="string">''</span> + <span class="keyword">this</span>.x;
}
alert(b.double());     <span class="comment">// '22' 字符串</span>
</pre></td></tr></table></figure>

<p>B类新定义的add方法会覆盖A类的同名方法。在B类的原型方法double()中可以调用A类的原型方法double()，从而避免代码耦合。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>B.prototype.double = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> B.sup.double.call(<span class="keyword">this</span>);     <span class="comment">// 内部调用</span>
}
</pre></td></tr></table></figure>

<h2 id="复制继承">复制继承</h2>
<p>之所以提一下复制继承，是因为这是继承的最原始的方法，它的思路也非常清晰：利用for in去遍历对象属性赋值给新的对象，<br>这种思路常常让我想起作业抄袭答案的场景。下面封装一个复制继承的函数：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(p, copy)</span> {</span>
    <span class="keyword">var</span> copy = copy || {};
    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> p) {
        <span class="keyword">if</span>((<span class="keyword">typeof</span> p[i]).toString().toLowerCase() === <span class="string">'object'</span>) {
            copy[i] = (p[i].constructor === <span class="built_in">Array</span>) ? []: {};
            extend(p[i], copy[i]);
        } <span class="keyword">else</span> {
            copy[i] = p[i];
        }
    }
    <span class="keyword">return</span> copy;
}
</pre></td></tr></table></figure>

<p>也有人说这样的拷贝思路是深拷贝，因为他对数组和对象进行了递归处理。<br>jQuery貌似也是用这种方式实现继承方法的。</p>
<p>针对上面的继承函数，下面简单测试一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> A = {
    name: <span class="string">'A'</span>
}

A.arr = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// 这个要写在extend()前面</span>
<span class="keyword">var</span> B = extend(A);
B.arr.push(<span class="number">3</span>)
alert(A.arr);   <span class="comment">// 1,2</span>
alert(B.arr);   <span class="comment">// 1,2,3</span>
</pre></td></tr></table></figure>

<p>在另外一本书上我看到了这样的封装方法，仅供参考：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>FUnction.prototype.extend = <span class="function"><span class="keyword">function</span><span class="params">(o)</span>{</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o) {
        <span class="keyword">this</span>.constructor.prototype[i] = o[i];
    }
}

<span class="comment">/* Test */</span>
<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">(x, y)</span> {</span>
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.y = y;
    <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;
    }
}
F.prototype.mul = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.x * <span class="keyword">this</span>.y;
}

<span class="keyword">var</span> f = <span class="keyword">new</span> F(<span class="number">2</span>, <span class="number">3</span>);
<span class="keyword">var</span> o = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
o.extend(<span class="keyword">new</span> F(<span class="number">2</span>, <span class="number">3</span>));
</pre></td></tr></table></figure>

<p>这段代码其实是通过反射机制，复制类对象的所有可枚举的属性和方法来模拟继承。对这段代码可以进行优化如下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="built_in">Function</span>.prototype.clone = <span class="function"><span class="keyword">function</span><span class="params">(o)</span> {</span>
    <span class="function"><span class="keyword">function</span> <span class="title">Temp</span><span class="params">()</span> {</span>};
    Temp.prototype = o;
    <span class="keyword">return</span> <span class="keyword">new</span> Temp();
}

<span class="keyword">var</span> o = <span class="built_in">Function</span>.clone(<span class="keyword">new</span> F(<span class="number">2</span>, <span class="number">3</span>));
alert(o.x);         <span class="comment">// 2</span>
alert(o.y);         <span class="comment">// 3</span>
alert(o.add());     <span class="comment">// 5</span>
alert(o.mul());     <span class="comment">// 6</span>
</pre></td></tr></table></figure>

<h2 id="小结">小结</h2>
<p>对JavaScript的语言来说，要了解的东西还是很多，继承只是其中冰山一角。<br>JavaScript的继承尽管多样化，相比较Java而言还是优雅而简洁的（不忘记黑一下Java）。<br>希望这篇文章能够对你有所帮助，写了很多废话，如果有什么不当的地方，请务必告诉我，非常感谢！</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://book.douban.com/subject/20366358/" target="_blank">编写高质量代码</a></li>
<li><a href="http://www.crockford.com/javascript/inheritance.html" target="_blank">Classical Inheritance in JavaScript</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank">阮一峰的网络日志</a></li>
</ol>
]]></content>
    <category scheme="http://beforeload.github.io/tags/JavaScript/" term="JavaScript"/>
    <category scheme="http://beforeload.github.io/categories/JavaScript/" term="JavaScript"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Closure of JavaScript]]></title>
    <link href="http://beforeload.github.io/2014/01/03/closure-of-javascript/"/>
    <id>http://beforeload.github.io/2014/01/03/closure-of-javascript/</id>
    <published>2014-01-03T14:17:17.000Z</published>
    <updated>2014-04-15T16:39:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_中的闭包">JavaScript 中的闭包</h1>
<p>这篇文章写的较早，而且内容太水，建议不要浪费时间去阅读它。有时间我会重写一下。</p>
<a id="more"></a>

<p>最近被人问到JavaScript中闭包的作用，无意中回忆起很久之前实习面试的时候也被问过类似的问题，想起在写JS中遇到的一些习惯性的问题，写篇博客总结一下。</p>
<h2 id="作用域">作用域</h2>
<p>我感觉很多JS开发人员在对作用域的了解上都存在错误，虽然JavaScript是一种类C 的语言，但它并不支持块级作用域，块级作用域是定义在代码块中的变量在代码块执行结束后会被释放掉。</p>
<p>在JavaScript中，则是通过函数作用域的方式，函数中的参数和变量在函数外不可见，而函数内自由使用，即内部任意位置定义的变量在函数内部任何地方都可见，当然定义变量时，请用var。为了避免块级作用域可能产生的问题，可以在函数体的顶部声明函数可能用到的所有变量。这也是很多前端开发人员的一个很好的习惯。</p>
<h2 id="闭包的产生">闭包的产生</h2>
<p>根据上面对作用域的描述，函数体内部可以访问外部函数的参数和变量（当然不包括this和arguments），这也叫做链式作用域(chain scope)。理解了作用域，闭包就变得很好理解了，我觉得可以这样简单的去理解它：一个定义在函数内部的函数，它可以访问创建时所处的上下文环境。这是最浅显的理解，当然它的作用远不止这些。</p>
<h2 id="闭包的作用">闭包的作用</h2>
<p>一个闭包最重要的作用不仅仅是可以读取函数内部的变量，更让人惊喜的是，<em>只要内部函数需要</em>，这些变量的值在内存中会一直存在。可以在控制台中写个简单的例子来演示它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>var <span class="built_in">add</span>
<span class="function"><span class="keyword">function</span> <span class="title">a</span>() {</span>
    var x = <span class="number">1</span>
    <span class="built_in">add</span> = <span class="function"><span class="keyword">function</span> () {</span>
        x += <span class="number">1</span>
    }

    <span class="function"><span class="keyword">function</span> <span class="title">b</span>() {</span>
        console.<span class="built_in">log</span>(x)
    }
    <span class="constant">return</span> b
}

var <span class="built_in">result</span> = <span class="operator">a</span>()
<span class="built_in">result</span>()<span class="comment"> // 1</span>
<span class="built_in">add</span>()
<span class="built_in">result</span>()<span class="comment"> // 2</span>
</pre></td></tr></table></figure>

<p>值得注意的是上面的例子中有两个闭包，add是一个匿名函数，也是一个闭包，它在函数外部定义，却在操作函数内部的变量。result是闭包b的函数，两次运行的值不同表示x值在内存中一直保存着，a调用结束后，x没有被回收。</p>
<p>如果上面例子理解有困难，那我们来简化它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> x = <span class="number">1</span>
    <span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span> {</span>
        x += <span class="number">1</span>
        console.log(x)
    }
    <span class="keyword">return</span> b  <span class="comment">// 注意，这个地方非常重要</span>
}
<span class="keyword">var</span> s = a()
s() <span class="comment">// 2</span>
s() <span class="comment">// 3</span>
</pre></td></tr></table></figure>

<p>现在只有一个闭包函数，这下子可以一眼看出来了吧。函数b嵌套在函数a内，函数a返回函数b。当函数b在函数a外部的一个变量引用时，就产生了闭包。</p>
<p>当然，由于长期保存在内存中不能释放，很多人也会遇到JavaScript内存泄露的问题(IE中)，这需要我们小心的使用闭包。有经验的前端工程师给出的建议是在推出函数之前，删除不使用的局部定义的变量。</p>
<h2 id="理解闭包">理解闭包</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> name = <span class="string">"The Window"</span>
<span class="keyword">var</span> object = {
    name: <span class="string">"My Object"</span>,   
    getNameFunc: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>   
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>   
            <span class="keyword">return</span> <span class="keyword">this</span>.name
        }   
    }   
}
console.log(object.getNameFunc()())
</pre></td></tr></table></figure>

<p>猜猜结果会是什么？<br>答案是：”The Window”</p>
<p>很显然，闭包函数在<code>getNameFunc</code>函数外部被调用，那么<code>this</code>就不指向<code>object</code>对象，而指向了全局的<code>window</code>，所以最后的结果是<code>window.name</code>，也就是”The Window”</p>
<p>通过闭包，我们可以很显然的观察到函数的<em>定义</em>和<em>执行</em>过程。使用闭包，一方面可以保护函数内变量的安全，实现私有属性和私有方法的作用，另一方面可以在内存中保持一个变量。</p>
<h2 id="JS中的GC机制">JS中的GC机制</h2>
<p>这里延伸一点，解释一下为什么产生闭包时，内部函数会比外部函数拥有更长的生命周期。这是由JS中的GC机制决定的。</p>
<p>在JavaScript中，如果一个对象不再被引用，那么这个对象就被GC回收。如果两个对象相互引用，但不会被第三个对象引用时，这两个对象都会被回收。但是，如果函数a被b引用，b又被函数a外的c引用，这样函数a执行完之后，却不会被回收了。</p>
<p>写在最后的话：关于闭包的东西远远不止这些，使用方式也复杂多样，但是万变不离其宗，理解它的机制可以帮助我们写出更加高效优雅的代码。</p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/JavaScript/" term="JavaScript"/>
    <category scheme="http://beforeload.github.io/categories/JavaScript/" term="JavaScript"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Vim Powerline installation on Ubuntu 13.10]]></title>
    <link href="http://beforeload.github.io/2014/01/02/vim-powerline-installation-on-ubuntu-1310/"/>
    <id>http://beforeload.github.io/2014/01/02/vim-powerline-installation-on-ubuntu-1310/</id>
    <published>2014-01-02T04:53:58.000Z</published>
    <updated>2014-01-02T07:38:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Ubuntu_13-10上安装vim-powerline">在Ubuntu 13.10上安装vim-powerline</h1>
<p> 最近又重装了一次ubuntu，发现在ubuntu上每次都要去找<code>vim-powerline</code>的安装及配置太麻烦，而Ubuntu上的字体每次都需要使用fontpather打一次补丁，不然<code>let g:Powerline_symbols = &#39;fancy&#39;</code>没有效果，下面的箭头无法显示出来。所以整理这篇博客，记录配置过程的一些问题和解决方法。</p>
<img src="http://i.stack.imgur.com/T6APG.png" title="Vim Powerline Normal">

<img src="http://i.stack.imgur.com/4R3XS.png" title="Vim Powerline Insert">

<img src="http://i.stack.imgur.com/VTB31.png" title="Vim Powerline Visual">

<img src="http://i.stack.imgur.com/HhgMo.png" title="Vim Powerline Replace">


<a id="more"></a>

<h2 id="一、安装Powerline">一、安装Powerline</h2>
<ol>
<li>首先安装python-pip和git:</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sudo apt<span class="attribute">-get</span> install python<span class="attribute">-pip</span> git
</pre></td></tr></table></figure>

<ol>
<li>安装Powerline</li>
</ol>
<p>分两种情况：<br>1) 对于个人用户</p>
<p>在控制台中运行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>pip install --user git+git:<span class="comment">//github.com/Lokaltog/powerline</span>
</pre></td></tr></table></figure>

<p>修改<code>~/.profile</code>，将<code>~/.local/bin</code>加到<code>$PATH</code>中，在末尾加上：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> [ <span class="operator">-d</span> <span class="string">"<span class="variable">$HOME</span>/.local/bin"</span> ]; <span class="keyword">then</span>
    PATH=<span class="string">"<span class="variable">$HOME</span>/.local/bin:<span class="variable">$PATH</span>"</span>
<span class="keyword">fi</span>
</pre></td></tr></table></figure>

<p>2) 对于系统用户</p>
<p>在控制台中运行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>su <span class="attribute">-c</span> <span class="string">'pip install git+git://github.com/Lokaltog/powerline'</span>
</pre></td></tr></table></figure>

<h2 id="二、字体的安装">二、字体的安装</h2>
<p>对于Ubuntu的用户来说，安装字体再简单不过了，只需要双击文件，点击Install即可。这里不在赘述。</p>
<p>不过，我发现从<a href="https://github.com/Lokaltog/powerline-fonts" target="_blank">powerline-fonts</a>上下载的字体不能直接用，还是需要配置，配置过程如下：</p>
<ol>
<li>Fontconfig：(推荐)</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sudo apt<span class="attribute">-get</span> install fontforge python<span class="attribute">-fontforge</span>
</pre></td></tr></table></figure>

<p>1) 对于个人用户</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>mkdir -p ~/<span class="preprocessor">.fonts</span>/ && cd ~/<span class="preprocessor">.fonts</span>/
wget https://github<span class="preprocessor">.com</span>/Lokaltog/powerline/raw/develop/font/PowerlineSymbols<span class="preprocessor">.otf</span> 
wget https://raw<span class="preprocessor">.github</span><span class="preprocessor">.com</span>/Lokaltog/powerline-fonts/master/SourceCodePro/Sauce%<span class="number">20</span>Code%<span class="number">20</span>Powerline%<span class="number">20</span>Black<span class="preprocessor">.otf</span>
~/<span class="preprocessor">.vim</span>/bundle/vim-powerline/fontpatcher/fontpatcher *<span class="preprocessor">.otf</span>
mkdir -p ~/<span class="preprocessor">.config</span>/fontconfig/conf<span class="preprocessor">.d</span>/ cd ~/<span class="preprocessor">.config</span>/fontconfig/conf<span class="preprocessor">.d</span>/ 
wget https://github<span class="preprocessor">.com</span>/Lokaltog/powerline/raw/develop/font/<span class="number">10</span>-powerline-symbols<span class="preprocessor">.conf</span>
fc-cache -vf ~/<span class="preprocessor">.fonts</span>
</pre></td></tr></table></figure>

<p>2) 对于系统用户</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>wget https://github<span class="preprocessor">.com</span>/Lokaltog/powerline/raw/develop/font/PowerlineSymbols<span class="preprocessor">.otf</span>
wget https://raw<span class="preprocessor">.github</span><span class="preprocessor">.com</span>/Lokaltog/powerline-fonts/master/SourceCodePro/Sauce%<span class="number">20</span>Code%<span class="number">20</span>Powerline%<span class="number">20</span>Black<span class="preprocessor">.otf</span>
wget https://github<span class="preprocessor">.com</span>/Lokaltog/powerline/raw/develop/font/<span class="number">10</span>-powerline-symbols<span class="preprocessor">.conf</span>
/etc/vim/bundle/vim-powerline/fontpatcher/fontpatcher *<span class="preprocessor">.otf</span>
sudo mv *<span class="preprocessor">.otf</span> /usr/share/fonts/
sudo fc-cache -vf
sudo mv <span class="number">10</span>-powerline-symbols<span class="preprocessor">.conf</span> /etc/fonts/conf<span class="preprocessor">.d</span>/
</pre></td></tr></table></figure>

<p>如果嫌麻烦，后面有我的打过补丁的字体可以直接下载使用。</p>
<h2 id="三、配置-vimrc">三、配置.vimrc</h2>
<ol>
<li>Vim状态栏的配置</li>
</ol>
<p>在<code>~/.vimrc</code>或者<code>/etc/vim/vimrc</code>文件中进行配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="built_in">set</span> encoding<span class="subst">=</span>utf<span class="subst">-</span><span class="number">8</span>
<span class="built_in">set</span> fillchars<span class="subst">+=</span>stl:<span class="subst">\</span> ,stlnc:<span class="subst">\</span>
<span class="built_in">set</span> laststatus<span class="subst">=</span><span class="number">2</span>
<span class="built_in">set</span> rtp<span class="subst">+=</span><span class="variable">$HOME</span><span class="subst">/</span><span class="built_in">.</span><span class="built_in">local</span>/lib/python2<span class="number">.7</span>/site<span class="attribute">-packages</span>/powerline/bindings/vim<span class="subst">/</span>
<span class="built_in">set</span> <span class="attribute">-g</span> default<span class="attribute">-terminal</span> <span class="string">"screen-256color"</span>
<span class="built_in">set</span> t_Co<span class="subst">=</span><span class="number">256</span>
<span class="keyword">let</span> g:Powerline_symbols <span class="subst">=</span> <span class="string">'fancy'</span>
</pre></td></tr></table></figure>

<p>后面附上我的vimrc相关配置。</p>
<h2 id="四、卸载">四、卸载</h2>
<p>1) 对于个人用户：</p>
<pre><code>pip uninstall powerline
</code></pre><p>2) 对于系统用户：</p>
<pre><code>su <span class="attribute">-c</span> <span class="string">'pip uninstall powerline'</span>
</code></pre><h3 id="附上我的字体配置文件">附上我的字体配置文件</h3>
<ol>
<li><a href="https://github.com/beforeload/dotfiles/tree/master/fonts" target="_blank">字体</a></li>
<li><a href="https://raw.github.com/beforeload/dotfiles/master/.vimrc" target="_blank">.vimrc</a></li>
</ol>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Linux/" term="Linux"/>
    <category scheme="http://beforeload.github.io/tags/Vim/" term="Vim"/>
    <category scheme="http://beforeload.github.io/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Introduction to Machine Learning]]></title>
    <link href="http://beforeload.github.io/2013/10/19/introduction-to-machine-learning/"/>
    <id>http://beforeload.github.io/2013/10/19/introduction-to-machine-learning/</id>
    <published>2013-10-19T12:25:13.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="机器学习简介">机器学习简介</h2>
<h3 id="一、定义">一、定义</h3>
<blockquote>
<p>Arthur Samuel (1959): Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed.<br>Tom Mitchell (1998) : Well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.</p>
</blockquote>
<a id="more"></a>

<p>个人理解，一句话就是不通过明确的编程让机器具有学习能力，以垃圾邮件为例：</p>
<ol>
<li>邮件分为垃圾邮件和非垃圾邮件为任务T；</li>
<li>查看哪些邮件被标记为垃圾邮件，以及哪些标记为非垃圾邮件是经验E；</li>
<li>正确识别垃圾邮件或非垃圾邮件比例（或数量）为P。</li>
</ol>
<h3 id="二、机器学习算法的类型">二、机器学习算法的类型</h3>
<p>(1) 监督学习(Supervised learning)</p>
<ol>
<li>概念： 通过生成一个函数将输入映射为一个合适的输出（通常也称为标记，多数情况下训练集都是有人工专家标注生成的）。</li>
<li>理解： 通过分好类的输入，模拟出一个函数，以预测相应的结果产生的概率。</li>
<li>问题： 分类问题（Classification）和回归问题（Regression）<ul>
<li>分类问题： 离散型（如预测乳腺癌良性、恶性还有预测明天下午5点会不会下雨），预测的离散输出值(0, 1)。</li>
<li>回归问题： 连续型（如预测房屋价格），预测结果为连续的输出值。</li>
</ul>
</li>
<li>案例：<ul>
<li>Given genetic (DNA) data from a person, predict the odds of him/her developing diabetes over the next 10 years.</li>
<li>Given 50 articles written by male authors, and 50 articles written by female authors, learn to predict the gender of a new manuscript’s author (when the identity of this author is unknown).</li>
</ul>
</li>
</ol>
<p>(2) 无监督学习(Unsupervised learning)</p>
<ol>
<li>概念： 与有监督学习相比，训练集没有人为标注的结果。</li>
<li>理解： 对输入的训练集没有进行标注，即不告诉你分类情况，让机器自己进行相应的分类，即无监督学习常见算法聚类。</li>
<li>案例： Google News， 基因序列分析，社会网络分析，市场切分等。</li>
<li>特别的例子： 鸡尾酒宴会。<ul>
<li>鸡尾酒问题算法： [W,s,v] = svd((repmat(sum(x.<em>x,1),size(x,1),1).</em>x)*x’);</li>
</ul>
</li>
</ol>
<p>(3) 半监督学习</p>
<p>介于监督学习与无监督学习之间。</p>
<p>(4) 强化学习(Reinforcement learning)</p>
<p>通过观察来学习如何做出动作，每个动作都会对环境有所影响，而环境的反馈又可以引导该学习算法。</p>
<p>(5) 其他</p>
<p>还有其他包括推荐系统，Transduction，Learning to learn等类型。</p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Machine Learning/" term="Machine Learning"/>
    <category scheme="http://beforeload.github.io/categories/Machine Learning/" term="Machine Learning"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Install JBPM 5.4]]></title>
    <link href="http://beforeload.github.io/2013/09/03/install-jbpm54/"/>
    <id>http://beforeload.github.io/2013/09/03/install-jbpm54/</id>
    <published>2013-09-03T14:49:38.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="JBPM5-4环境搭建">JBPM5.4环境搭建</h2>
<h3 id="Step_1:_准备工作">Step 1: 准备工作</h3>
<ol>
<li>下载JDK，安装配置Java环境</li>
<li>下载Ant，配置Java自动化脚本引擎</li>
</ol>
<a id="more"></a>

<p><strong>备注:</strong></p>
<ol>
<li>Linux的JDK安装可以参考我的另外<a href="http://beforeload.github.io/2013/06/29/building-distributed-systems-development-environment/">一篇博文</a></li>
<li>Windows的安装可以参考<a href="http://www.cnitblog.com/intrl/archive/2009/04/11/56254.aspx" target="_blank">这里</a></li>
</ol>
<h3 id="Step_2:_下载JBPM_5-4安装相关开发工具">Step 2: 下载JBPM 5.4安装相关开发工具</h3>
<ol>
<li>下载<a href="http://softlayer-dal.dl.sourceforge.net/project/jbpm/jBPM%205/jbpm-5.4.0.Final/jbpm-5.4.0.Final-installer-full.zip" target="_blank">jbpm-5.4.0.Final-installer-full.zip</a></li>
<li><p>解压缩，从控制台(Windows用户是command)进入相应文件夹下，然后输入命令</p>
<p> ant install.demo</p>
</li>
</ol>
<p>这个过程是下载Eclipse, Jboss等工具，自动化构建开发环境。</p>
<p>备注： 之所以选择这样的构建方式，是因为不想在环境搭建上浪费太多时间，以便拥有更多的时间投入JBPM5的学习开发过程中。</p>
<h3 id="Step_3:_测试环境是否搭建成功">Step 3: 测试环境是否搭建成功</h3>
<ol>
<li><p>启动JBPM</p>
<p> ant start.demo</p>
</li>
</ol>
<p>在控制中可以看到相关的启动情况，会看到自动化的启动了若干组件。</p>
<ol>
<li>重点是测试JBoss启动</li>
</ol>
<p>在控制台输入<a href="http://localhost:8080/，会看到Jboss启动的情况，大致应该如下所示：" target="_blank">http://localhost:8080/，会看到Jboss启动的情况，大致应该如下所示：</a></p>
<img src="http://i.minus.com/iHKyfjT9AxDg8.png">


<ol>
<li>Web管理控制台</li>
</ol>
<p>打开浏览器，输入<a href="http://localhost:8080/jbpm-console，重点看一下" target="_blank">http://localhost:8080/jbpm-console，重点看一下</a></p>
<p>登录的用户名、密码均为krisv </p>
<ol>
<li>使用Guvnor仓库和设计 </li>
</ol>
<p>输入如下地址可以进入</p>
<p><a href="http://localhost:8080/drools-guvnor" target="_blank">http://localhost:8080/drools-guvnor</a></p>
<p>最后，视频演示请戳<a href="http://people.redhat.com/kverlaen/install-gwt-console-jbpm.swf" target="_blank">这里</a></p>
<h3 id="参考博文：">参考博文：</h3>
<ol>
<li><a href="http://wanglu271991027.iteye.com/blog/1495799" target="_blank">jbpm5.2学习———安装与配置</a></li>
<li><a href="http://www.cnblogs.com/skyme/archive/2011/11/07/2238782.html" target="_blank">JBPM5.1的介绍</a></li>
<li><a href="http://w26.iteye.com/blog/998431" target="_blank">jBPM5 入门</a></li>
<li><a href="http://blog.chinaunix.net/uid-122937-id-3731868.html" target="_blank">Jbpm5安装</a></li>
</ol>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Linux/" term="Linux"/>
    <category scheme="http://beforeload.github.io/tags/Ubuntu/" term="Ubuntu"/>
    <category scheme="http://beforeload.github.io/tags/Java/" term="Java"/>
    <category scheme="http://beforeload.github.io/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[The Master Method]]></title>
    <link href="http://beforeload.github.io/2013/07/21/the-master-method/"/>
    <id>http://beforeload.github.io/2013/07/21/the-master-method/</id>
    <published>2013-07-21T02:53:44.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<p>T(n) &lt;= aT(n/b) + O(n<sup>d</sup>)</p>
<p>T(n) = O(n<sup>d</sup>logn) if a = b<sup>d</sup> (Case 1)</p>
<p>T(n) = O(n<sup>d</sup>) if a &lt; b<sup>d</sup> (Case 2)</p>
<p>T(n) = O(n<sup>log<sub>b</sub>a</sup>) if a &gt; b<sup>d</sup> (Case 3)</p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Algorithm/" term="Algorithm"/>
    <category scheme="http://beforeload.github.io/tags/Math/" term="Math"/>
    <category scheme="http://beforeload.github.io/categories/Algorithm/" term="Algorithm"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Summary of Distributed Computing Learning Resourses]]></title>
    <link href="http://beforeload.github.io/2013/07/11/summary-of-distribute-computing-learning-resourses/"/>
    <id>http://beforeload.github.io/2013/07/11/summary-of-distribute-computing-learning-resourses/</id>
    <published>2013-07-11T13:01:59.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="分布式计算相关资源总结">分布式计算相关资源总结</h2>
<h3 id="论文">论文</h3>
<p>首先是论文，强烈建议看英文原版，那些翻译的还是敬而远之吧！</p>
<blockquote>
<p>Google出品，必属精品！</p>
</blockquote>
<a id="more"></a>

<h4 id="四大经典论文(必看)">四大经典论文(必看)</h4>
<ol>
<li><p>The Anatomy of a Large-Scale Hypertextual Web Search Engine</p>
<p>分布式计算的奠基制作，介绍了Google搜索引擎的原型，讲解了一个基于超文本的大型系统建立过程。</p>
</li>
<li><p>The Google File System</p>
<p>GFS这篇论文已然成为分布式文件系统相关技术的一种标准。对于分布式应用的接口，分布式系统设计，<br>数据的存储以及分布式系统监控和管理相关的技术实现具有指导意义。</p>
</li>
<li><p>MapReduce: Simplified Data Processing on Large Clusters</p>
<p>MapReduce的奠基之作，就凭它提出了MapReduce编程模式，就必须要读这篇论文。通过它，可以初窥云计算的世界。<br>Google在四位数以上的个节点上运行MapReduce，并且还在持续扩展中。</p>
</li>
<li><p>BigTable: A Distributed Storage System for Structured Data.</p>
<p>这篇论文主要实现了分布式存储数据的结构化，Google Earth和网页索引都是基于BigTable实现。论文很清晰的讲解了BigTable的设计实现思路和方法。</p>
</li>
</ol>
<h4 id="三篇补充论文(推荐看)">三篇补充论文(推荐看)</h4>
<ol>
<li><p>Dynamo</p>
<p>Google原始之作！</p>
</li>
<li><p><a href="http://www.sosp2007.org/papers/sosp064-aguilera.pdf" target="_blank">Sinfonia: A New Paradigm for Building Scalable Distributed Systems</a></p>
<p>阐述构建分布式文件系统的范式方法。淘宝构建TFS，OceanBase和Tair等系统的时候充分参考了这篇论文！</p>
</li>
<li><p><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/zh-CN//archive/chubby-osdi06.pdf" target="_blank">The Chubby lock service for loosely-coupled distributed systems</a></p>
<p>Google的BigTable，MapReduce和Spanner服务都是在这个基础上构建的！分布式事务的基础，我正在看这篇论文。</p>
</li>
<li><p><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/es//archive/spanner-osdi2012.pdf" target="_blank">Spanner: Google’s Globally-Distributed Database</a></p>
</li>
</ol>
<p>第一个全球意义上的分布式数据库，推荐它的其中一个原因是，我完全看不懂！！！</p>
<h4 id="其他论文">其他论文</h4>
<p>这里还有一份别人总结的<a href="http://duanple.blog.163.com/blog/static/709717672011330101333271/" target="_blank">分布式系统领域经典论文翻译集</a>。</p>
<p><strong><em>论文来源和下载：</em></strong></p>
<p>大多数论文来源于OSDI上。可以直接去会议网站上下载。直接google scholar一下，也可以下载。</p>
<h3 id="书籍">书籍</h3>
<h4 id="分布式计算">分布式计算</h4>
<ol>
<li><a href="http://book.douban.com/subject/3108801/" target="_blank">分布式系统原理与范型</a></li>
<li><a href="http://book.douban.com/subject/2698938/" target="_blank">分布式系统概念与设计</a></li>
</ol>
<h4 id="Hadoop">Hadoop</h4>
<ol>
<li><p>《Hadoop in action》、 《Hadoop实战》</p>
<p>我看的第一本分布式计算的书，里面的内容有点老。入门的书籍，所以推荐的时候难免掺杂了感情分。</p>
</li>
<li><p>《Oreilly.Hadoop.The.Definitive.Guide.2nd.Edition 》</p>
<p>中文版本就不推荐了，直接看英文版的吧！</p>
</li>
<li><p>《Hadoop权威指南》</p>
</li>
</ol>
<p>这本书同样适合初学者，书里面有基础的实例实现。属于分布式计算方面少数可以看的中文书。<br>翻译的比较成功的两本书！当然看原版更好！</p>
<h4 id="其他书籍">其他书籍</h4>
<ol>
<li>《推荐系统实践》</li>
<li>《集体智慧编程》</li>
</ol>
<h3 id="其他Hadoop教程">其他Hadoop教程</h3>
<ol>
<li>《深入浅出Hadoop实战开发30讲》</li>
<li>《Hadoop应用开发实战 28讲》</li>
<li>《Cloudera Hadoop 4系列实战课程40讲》</li>
</ol>
<h3 id="总结">总结</h3>
<p>学习分布式计算，建议先去研究一下分布式计算的理论知识，然后学习一种框架，以Hadoop为例，从入门到精通！</p>
<ol>
<li><p>环境搭建</p>
<p><a href="http://beforeload.github.io/2013/06/29/building-distributed-systems-development-environment/">基于Hadoop的分布式系统开发环境在Ubuntu 13.04中的搭建</a></p>
</li>
<li><p>MapReduce</p>
<p><a href="http://beforeload.github.io/2013/04/13/analyze-mapreduce/">MapReduce</a></p>
</li>
<li><p>Hadoop的一点应用</p>
<ul>
<li><a href="http://beforeload.github.io/2013/04/06/hdfs-java-api/">理解 Hadoop 的 Java API</a></li>
<li><a href="http://beforeload.github.io/2013/04/18/invertedindex-in-hadoop/">倒排索引</a></li>
</ul>
</li>
</ol>
<p>看论文和书籍只是一部分，懂理论才算刚刚入门！要努力做到能应用还要争取有创新！</p>
<p>另外, Hadoop不代表分布式，还有很多类似于Hadoop且比Hadoop更具有优势的框架，如Spark就更适合实验室内的研究的小规模分布式系统，Storm更适用于实时数据流。</p>
<p>附： </p>
<ol>
<li><a href="http://aoyouzi.iteye.com/blog/1845235" target="_blank">推荐系统公共资源汇总</a></li>
</ol>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Distributed Computing/" term="Distributed Computing"/>
    <category scheme="http://beforeload.github.io/tags/Hadoop/" term="Hadoop"/>
    <category scheme="http://beforeload.github.io/tags/Linux/" term="Linux"/>
    <category scheme="http://beforeload.github.io/categories/Distributed Computing/" term="Distributed Computing"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Building Distributed Systems Development Environment]]></title>
    <link href="http://beforeload.github.io/2013/06/29/building-distributed-systems-development-environment/"/>
    <id>http://beforeload.github.io/2013/06/29/building-distributed-systems-development-environment/</id>
    <published>2013-06-28T17:13:47.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基于Hadoop的分布式系统开发环境在Ubuntu_13-04中的搭建">基于Hadoop的分布式系统开发环境在Ubuntu 13.04中的搭建</h2>
<p>由于实验学习以及开发测试的需求，需要安装集群和伪分布式开发环境。</p>
<p>分为以下安装过程：</p>
<ol>
<li>安装jdk</li>
<li>安装eclipse</li>
<li>安装hadoop</li>
</ol>
<a id="more"></a>

<h3 id="安装jdk">安装jdk</h3>
<p><strong>(1) 下载JDK</strong></p>
<p>Ubuntu上下载最好不要使用FTP下载，不然会出现例如下面的问题。</p>
<pre><code>gzip: stdin: invalid compressed data--format violatedtar: Unexpected EOF <span class="keyword">in</span> archivetar: Unexpected EOF <span class="keyword">in</span> archivetar: <span class="keyword">Error</span> <span class="keyword">is</span> <span class="keyword">not</span> recoverable: exiting <span class="built_in">now</span>
</code></pre><p>从<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank">官网</a>上根据自己的系统下载相应的JDK。</p>
<pre><code>sudo mkdir /usr/java
tar zxvf jdk-<span class="number">7</span>u25-linux-x64<span class="preprocessor">.tar</span><span class="preprocessor">.gz</span>
sudo mv jdk-<span class="number">7</span>u25-linux-x64<span class="preprocessor">.tar</span><span class="preprocessor">.gz</span> /usr/java/
</code></pre><p><strong>(2) 然后修改配置文件</strong></p>
<pre><code><span class="built_in">sudo</span> vi /etc/profile
</code></pre><p>按G可以直接到文件尾端，填写下面内容:</p>
<pre><code><span class="keyword">export</span> JAVA_HOME=/usr/java/jdk1.<span class="number">7.0</span>_25
<span class="keyword">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre
<span class="keyword">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar
<span class="keyword">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin
</code></pre><p>保存退出。</p>
<p><strong>(3) 检测是否成功</strong> </p>
<pre><code><span class="built_in">source</span> /etc/profile
java -version
</code></pre><p>如果显示下面结果，表示安装成功。</p>
<pre><code>java version <span class="string">"1.7.0_25"</span>
Java(TM) SE Runtime Environment (build <span class="number">1.7</span><span class="number">.0</span>_25<span class="attribute">-b15</span>)
Java HotSpot(TM) <span class="number">64</span><span class="attribute">-Bit</span> Server VM (build <span class="number">23.25</span><span class="attribute">-b01</span>, mixed mode)
</code></pre><h3 id="安装eclipse">安装eclipse</h3>
<p><strong>(1) 下载eclipse<em>*</em>.tar.gz</strong></p>
<pre><code>tar zxvf eclipse-standard-kepler-R-linux-gtk-x86_64.tar.gz
mv eclipse /usr/<span class="built_in">local</span>
/usr/<span class="built_in">local</span>/eclipse/eclipse    <span class="comment">#启动eclipse</span>
</code></pre><p><strong>(2) 通过修改快捷键，可以迅速启动eclipse</strong></p>
<pre><code><span class="type">System</span> <span class="type">Settings</span> -&gt; <span class="type">Keyboard</span> -&gt; <span class="type">Shortcuts</span> -&gt; <span class="type">Custom</span> <span class="type">Shortcuts</span>
</code></pre><p><strong><em>在弹窗中输入：</em></strong></p>
<pre><code><span class="attribute">Name</span>: <span class="string">eclipse</span>
<span class="attribute">Command</span>: <span class="string">/usr/local/eclipse/eclipse</span>
</code></pre><p>Apply退出后，<code>Ctrl+Alt+E</code>，添加快捷键。以后只需要通过<code>Ctrl+Alt+E</code>，即可启动Eclipse。</p>
<h4 id="ssh_无密码登录">ssh 无密码登录</h4>
<p><strong>(1) 安装SSH</strong></p>
<pre><code>sudo apt-<span class="keyword">get</span> install openssh-<span class="built_in">server</span>
</code></pre><p>如果你想让别的机器访问自己的电脑，只需要把公钥告诉别人，其他机器通过public key加密后，把数据传到自己的机器上，自己的机器用私钥进行解密。</p>
<p><strong>(2) 生成密钥的步骤也很简单：</strong></p>
<pre><code>ssh<span class="attribute">-keygen</span> <span class="attribute">-t</span> rsa <span class="attribute">-C</span> <span class="string">"your_email@example.com"</span>
</code></pre><p>详细步骤请参见<a href="//help.github.com/articles/generating-ssh-keys">Generating SSH Keys</a></p>
<pre><code><span class="keyword">cp</span> id_rsa<span class="preprocessor">.pub</span> authorized_keys
</code></pre><p><strong>(3) 测试一下，是否可以无密码连接</strong></p>
<pre><code>ssh localhost
</code></pre><p>集群配置的时候可以直接从namenode中，把新增的电脑上的public key发到namenode中，添加到它的authorized_keys中，<br>然后使用<code>scp</code>命令拷贝到新增机器上即可。</p>
<h4 id="安装Hadoop">安装Hadoop</h4>
<p><strong>(1) 下载解压hadoop</strong></p>
<pre><code>tar zxvf hadoop-<span class="number">0.20</span><span class="number">.2</span><span class="preprocessor">.tar</span><span class="preprocessor">.gz</span>    <span class="preprocessor">#解压</span>
</code></pre><p><strong>(2) 配置四个文件</strong></p>
<p>1) ~/hadoop-0.20.2/conf/hadoop-env.sh</p>
<pre><code><span class="keyword">export</span> JAVA_HOME=/usr/java/jdk1.<span class="number">7.0</span>_25
</code></pre><p>2) ~/hadoop-0.20.2/conf/core-site.xml</p>
<pre><code><span class="tag">&lt;<span class="title">configuration</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</code></pre><p>3) ~/hadoop-0.20.2/conf/hdfs-site.xml</p>
<pre><code><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>1<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</code></pre><p>4) ~/hadoop-0.20.2/conf/mapred-site.xml</p>
<pre><code><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.job.tracker<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>localhost:9001<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</code></pre><p><strong>(3) 修改～/.bashrc</strong></p>
<pre><code><span class="built_in">echo</span> <span class="string">'export HADOOP_HOME=/home/beforeload/hadoop-0.20.2'</span> &gt;&gt; ~/.bashrc
<span class="built_in">echo</span> <span class="string">'export PATH=$PATH:$HADOOP_HOME/bin'</span> &gt;&gt; ~/.bashrc
<span class="built_in">source</span> ~/.bashrc
</code></pre><p>现在在任何目录下，都可以输入hadoop命令了。</p>
<p><strong>(4) 格式化HDFS并启动hadoop</strong></p>
<pre><code>hadoop namenode -format
start-<span class="built_in">all</span>.sh
jps   <span class="preprocessor">#查看运行的进程</span>
</code></pre><p><strong>(5) 浏览NameNode 和 JobTracker</strong></p>
<ol>
<li>NameNode <a href="http://localhost:50070/dfshealth.jsp" target="_blank">http://localhost:50070/dfshealth.jsp</a></li>
<li>JobTracker <a href="http://localhost:50030/jobtracker.jsp" target="_blank">http://localhost:50030/jobtracker.jsp</a></li>
</ol>
<p><strong>(6) 重要参数</strong></p>
<pre><code><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span>     
<span class="built_in">echo</span> <span class="variable">$HADOOP_HOME</span>
</code></pre>]]></content>
    <category scheme="http://beforeload.github.io/tags/Ubuntu/" term="Ubuntu"/>
    <category scheme="http://beforeload.github.io/tags/Linux/" term="Linux"/>
    <category scheme="http://beforeload.github.io/tags/Hadoop/" term="Hadoop"/>
    <category scheme="http://beforeload.github.io/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Building Webapps with Yeoman]]></title>
    <link href="http://beforeload.github.io/2013/06/28/building-webapps-with-yeoman/"/>
    <id>http://beforeload.github.io/2013/06/28/building-webapps-with-yeoman/</id>
    <published>2013-06-28T14:11:40.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="使用Yeoman_快速构建Web应用">使用Yeoman 快速构建Web应用</h2>
<h4 id="简介">简介</h4>
<p>Yeoman不仅仅是一个应用。它也是一个工作流，一个工具集。</p>
<p>相关介绍参见<a href="http://yeoman.io/" target="_blank">官网文档</a>。</p>
<a id="more"></a>

<p>它由三个组件组成：</p>
<ol>
<li>Yo 脚手架工具：我理解成项目工程目录和文件生成工具。用来构建生产环境和生成编译环境。</li>
<li>Grunt 构建工具：主要用来构建，预览和测试你的项目。</li>
<li>Bower 包管理工具：处理包依赖关系，不需要手动下载管理脚本。可以理解成前端的NPM。</li>
</ol>
<p><strong>协作关系图：</strong></p>
<img src="//images.cnitblog.com/blog/39469/201303/09214923-27fe6dea6eb34f468e601589ea83a675.png" class="[yo-grunt-bower]">


<p>从上面流水线一样的协作图，可以看出一个项目产品的生成可以做到很规范化，从而提高生成效率。</p>
<p>我觉得在说应用之前，先要思考一下使用Yeoman的场景，如果是我们负责一个项目，思考一下如下的问题：</p>
<ol>
<li>项目目录是怎样的？</li>
<li>需要用到哪些类库？</li>
<li>(基于PHP和基于Node.js)生产环境是怎样的？</li>
<li>如果使用CoffeeScript/sass/less，又需要增加什么样的编译环境？</li>
<li>单元测试要如何进行？</li>
<li>调试环境是怎么样的？</li>
<li>打包部署要遵循什么样的流程？</li>
<li>…</li>
</ol>
<p>这些问题不能很好的解决，项目开发中都会存在或多或少的效率问题。</p>
<p>其实，解决他们很简单，yeoman提供方便快捷的解决方法，下面简单介绍一下如何构建一个项目。</p>
<h3 id="安装它">安装它</h3>
<p>第一步：首先确认拥有Node.js, Ruby的环境。</p>
<p>最好安装一下 Compass(Sass的工具库)</p>
<pre><code><span class="built_in">sudo</span> gem install compass
</code></pre><p>如果想了解一下Compass，推荐阮一峰的一篇<a href="http://www.ruanyifeng.com/blog/2012/11/compass.html" target="_blank">博文</a>。</p>
<p>第二步：然后安装三个组件</p>
<pre><code>sudo npm install <span class="attribute">-g</span> yo grunt<span class="attribute">-cli</span> bower
</code></pre><p>第三步：安装网络应用生成器</p>
<p>选择web app生成器：</p>
<pre><code>sudo npm install <span class="attribute">-g</span> generator<span class="attribute">-webapp</span>
</code></pre><p>也可以选择安装AngularJS生成器：</p>
<pre><code><span class="built_in">sudo</span> npm install -g generator-angular  <span class="comment"># install generator</span>
</code></pre><h3 id="快速构建">快速构建</h3>
<p>由于上面web应用生成器有两种，所以可以通过两种不同的方式构建我们的项目：</p>
<p>第一种：使用<code>yo webapp</code>方式</p>
<pre><code>yo webapp                     <span class="comment"># 搭建项目骨架</span>
bower <span class="keyword">install</span> underscore      <span class="comment"># 依赖通过bower安装</span>
grunt                         <span class="comment"># 构建测试发布环境</span>
</code></pre><p>第二种：使用<code>yo angular</code>方式</p>
<pre><code>yo angular                    <span class="preprocessor"># 搭建项目骨架</span>
bower install angular-ui      <span class="preprocessor"># 依赖通过bower安装</span>
grunt test                    <span class="preprocessor"># 测试</span>
grunt <span class="keyword">server</span>                  <span class="preprocessor"># 预览</span>
grunt  
</code></pre><h3 id="总结">总结</h3>
<p>通过以上的步骤，我们很容易的构建出了一个简易的web项目。yeoman有很多特性，例如可以自定义模板（如HTML5, Boilerplate, Twitter Bootstrap等），AMD（通过RequireJS）等其他工具。</p>
<p>自动编译CoffeeScript和Compass也是一大亮点，值得一提的是，yeoman提供了live reload功能，在对项目文件修改保存后，前端页面回自动刷新。</p>
<p>还有太多太多特性了，如jslint完善脚本，内置HTTP服务器，集成包管理，ES6的语法支持，PhantomJS单元测试等等。希望大家使用愉快。</p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Node.js/" term="Node.js"/>
    <category scheme="http://beforeload.github.io/categories/Node.js/" term="Node.js"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Common Software Installation and Configuration on Ubuntu 13.04]]></title>
    <link href="http://beforeload.github.io/2013/06/22/my-software-installation-and-configuration-on-ubuntu-1304/"/>
    <id>http://beforeload.github.io/2013/06/22/my-software-installation-and-configuration-on-ubuntu-1304/</id>
    <published>2013-06-22T13:23:50.000Z</published>
    <updated>2014-01-12T08:37:52.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Ubuntu_13-04上常用软件的安装配置">在Ubuntu 13.04上常用软件的安装配置</h1>
<p>安装完Ubuntu 13.04 后，我的一些软件安装和配置过程。</p>
<ol>
<li><a href="#-5b89-88c5-zsh-548c-oh-my-zsh">安装zsh和oh-my-zsh</a></li>
<li><a href="#Ubuntu_-7ec8-7aef-900f-660e-5316-">终端透明化</a></li>
<li><a href="#-5b89-88c5-_chrome">安装chrome</a></li>
<li><a href="#-5b89-88c5-git">安装git</a></li>
<li><a href="#-5b89-88c5-VLC-89c6-9891-64ad-653e-5668-">安装VLC播放器</a></li>
<li><a href="#-5b89-88c5-sougou_-2b-_fcitx">安装fcitx + 搜狗拼音</a></li>
<li><a href="#-5b89-88c5-914d-7f6e-VIM">安装vim</a></li>
<li><a href="#-5b89-88c5-Node-js">安装Node.js</a></li>
<li><a href="#-5b89-88c5-9510-6377-6821-56ed-7f51-5ba2-6237-7aef-">安装锐捷校园网客户端</a></li>
<li><a href="#-5b89-88c5-914d-7f6e-JDK">安装配置jdk</a></li>
</ol>
<a id="more"></a>

<h2 id="安装zsh和oh-my-zsh">安装zsh和oh-my-zsh</h2>
<p><strong><em>安装 curl:</em></strong></p>
<pre><code><span class="built_in">sudo</span> apt-get install curl
</code></pre><p>然后:</p>
<pre><code><span class="built_in">sudo</span> apt-get install zsh
</code></pre><p><strong><em>可以通过curl方式安装：</em></strong></p>
<pre><code>curl -<span class="constant">L</span> <span class="symbol">https:</span>/<span class="regexp">/github.com/robbyrussell</span><span class="regexp">/oh-my-zsh/raw</span><span class="regexp">/master/tools</span><span class="regexp">/install.sh | sh</span>
</code></pre><p><strong><em>也可以通过wget：</em></strong></p>
<pre><code>wget --no-check-certificate <span class="symbol">https:</span>/<span class="regexp">/github.com/robbyrussell</span><span class="regexp">/oh-my-zsh/raw</span><span class="regexp">/master/tools</span><span class="regexp">/install.sh -O - | sh</span>
</code></pre><p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank">参考文档</a></p>
<h2 id="Ubuntu_终端透明化">Ubuntu 终端透明化</h2>
<p>Ctrl+Alt+T 打开终端，菜单 </p>
<pre><code><span class="type">Edit</span>-&gt;<span class="type">Profile</span> <span class="type">Preference</span>-&gt;<span class="type">Background</span>-&gt;<span class="type">Transparent</span> background
</code></pre><h2 id="安装_chrome">安装 chrome</h2>
<p><strong><em>安装依赖:</em></strong></p>
<pre><code><span class="built_in">sudo</span> apt-get install (依赖包)
</code></pre><p>然后从google chrome官方网站上下载安装</p>
<pre><code>sudo dpkg <span class="attribute">-i</span> google<span class="attribute">-chrome</span><span class="attribute">-stable_</span><span class="subst">*</span><span class="built_in">.</span>deb
</code></pre><p>终端输入<code>google-chrome</code>即可启动。</p>
<h2 id="安装git">安装git</h2>
<pre><code><span class="built_in">sudo</span> apt-get install git
</code></pre><p><strong><em>相关配置:</em></strong></p>
<pre><code>git config --<span class="keyword">global</span> user.name beforeload
git config --<span class="keyword">global</span> user.email fe.daniel91<span class="variable">@gmail</span>.com
git config --<span class="keyword">global</span> <span class="keyword">color</span>.diff auto
git config --<span class="keyword">global</span> <span class="keyword">color</span>.branch auto
git config --<span class="keyword">global</span> <span class="keyword">color</span>.ui true
git config --<span class="keyword">global</span> <span class="keyword">color</span>.interactive auto
git config --<span class="keyword">global</span> <span class="keyword">color</span>.status auto
git config --<span class="keyword">global</span> push.<span class="keyword">default</span> current
git config --<span class="keyword">global</span> core.<span class="keyword">editor</span> vim
git config --<span class="keyword">global</span> core.autocrlf off
git config --<span class="keyword">global</span> merge.tool vimdiff
</code></pre><h3 id="查看配置">查看配置</h3>
<p><strong><em>查看所有配置:</em></strong></p>
<pre><code><span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">list</span>
</code></pre><p><strong><em>查看某个配置:</em></strong></p>
<pre><code>git config user<span class="preprocessor">.name</span>
</code></pre><p>或者 </p>
<pre><code>cat ~/<span class="preprocessor">.gitconfig</span>
</code></pre><h2 id="安装VLC视频播放器">安装VLC视频播放器</h2>
<pre><code><span class="built_in">sudo</span> apt-get install vlc
</code></pre><p>终端输入<code>vlc</code>启动，在菜单栏</p>
<pre><code><span class="type">Tools</span>-&gt; <span class="type">Preference</span> -&gt; <span class="type">Subtitles</span> &amp; <span class="type">OSD</span> 修改<span class="type">Default</span> encoding为<span class="type">Universal</span>(<span class="type">UTF</span>-<span class="number">8</span>),或者<span class="type">GBK</span>
</code></pre><p>还可以设置相关中文字体（中文可选）。</p>
<p>然后在右上角:</p>
<pre><code><span class="type">System</span> <span class="type">Settings</span> -&gt; <span class="type">Details</span> -&gt; <span class="type">Default</span> <span class="type">Applications</span> -&gt; <span class="type">Video</span>选择<span class="type">VLC</span> media player
</code></pre><p>这样打开相关视频文件，可以直接使用VLC播放。</p>
<h2 id="安装sougou_+_fcitx">安装sougou + fcitx</h2>
<pre><code>sudo add<span class="attribute">-apt</span><span class="attribute">-repository</span> ppa:fcitx<span class="attribute">-team</span>/nightly
sudo apt<span class="attribute">-get</span> update
sudo apt<span class="attribute">-get</span> install fcitx<span class="attribute">-sogoupinyin</span>
</code></pre><p>然后在<code>System Settings -&gt; Language Support -&gt; Keyboard input method system</code> 中选择 fcitx。</p>
<p><strong><em>[可选]安装皮肤：</em></strong></p>
<p>下载<a href="http://pan.baidu.com/share/link?shareid=591450&amp;uk=4060302862" target="_blank">fcitx-sougou-skin</a></p>
<pre><code>sudo dpkg <span class="attribute">-i</span> fcitx<span class="attribute">-skin</span><span class="attribute">-sogou_0</span><span class="number">.0</span><span class="number">.2</span>_all<span class="built_in">.</span>deb
</code></pre><p>在fcitx外观中选择sougou即可。</p>
<p>最后注销，重新登录，输入法生效。</p>
<h2 id="安装配置VIM">安装配置VIM</h2>
<pre><code><span class="built_in">sudo</span> apt-get install vim
</code></pre><p><strong><em>配置：</em></strong></p>
<p>安装vundle</p>
<pre><code>git clone https://github<span class="preprocessor">.com</span>/gmarik/vundle<span class="preprocessor">.git</span> ~/<span class="preprocessor">.vim</span>/bundle/vundle
</code></pre><p>用<a href="https://github.com/beforeload/myconf/blob/master/.vimrc" target="_blank">我的.vimrc配置文件</a><br>覆盖<code>~/.vimrc</code>文件即可</p>
<p>在vim中执行<code>:BundleInstall</code>,自动安装vim插件。</p>
<p>Powerline中下面的箭头可能存在字体问题，解决的办法是给字体打补丁。</p>
<h2 id="安装Node-js">安装Node.js</h2>
<p>安装依赖</p>
<pre><code>sudo apt<span class="attribute">-get</span> install build<span class="attribute">-essential</span> libssl<span class="attribute">-dev</span>
</code></pre><p>编译安装</p>
<pre><code>mkdir node &amp;&amp; cd node
git clone https:<span class="comment">//github.com/joyent/node.git</span>
./configure
<span class="built_in">make</span> 
<span class="built_in">make</span> install
</code></pre><h2 id="安装锐捷校园网客户端">安装锐捷校园网客户端</h2>
<p>下载<a href="http://ncs.hust.edu.cn/download/soft/Linux\ SU\ V1.01版.rar" target="_blank">Linux SU V 1.01</a></p>
<p>安装unrar</p>
<pre><code>sudo apt-get install unrar

unrar ***<span class="preprocessor">.rar</span>
tar -zxvf ***<span class="preprocessor">.tar</span><span class="preprocessor">.gz</span>

cd rjsupplicant/
</code></pre><p>查看设置</p>
<pre><code><span class="built_in">sudo</span> ./rjsupplicant.sh -h
</code></pre><p>设置好后启动</p>
<pre><code><span class="built_in">sudo</span> ./rjsupplicant.sh
</code></pre><h2 id="安装配置JDK">安装配置JDK</h2>
<p>相关安装步骤已经在另外<a href="//beforeload.github.io/2013/06/29/building-distributed-systems-development-environment/">一篇博文</a>中做出更新。</p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Ubuntu/" term="Ubuntu"/>
    <category scheme="http://beforeload.github.io/tags/Linux/" term="Linux"/>
    <category scheme="http://beforeload.github.io/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[building PhoneGap development environment]]></title>
    <link href="http://beforeload.github.io/2013/06/12/building-phonegap-development-environment/"/>
    <id>http://beforeload.github.io/2013/06/12/building-phonegap-development-environment/</id>
    <published>2013-06-11T18:29:06.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Ubuntu_13-04_Android开发基本环境配置">Ubuntu 13.04 Android开发基本环境配置</h3>
<h4 id="基本环境">基本环境</h4>
<pre><code>sudo apt<span class="attribute">-get</span> install ia32<span class="attribute">-libs</span> <span class="variable">#64</span>位系统的<span class="number">32</span>位程序兼容库adb需要此库(<span class="number">32</span>位系统的当然略过此步骤)
sudo apt<span class="attribute">-get</span> install ant
</code></pre><a id="more"></a>

<h4 id="安装独立SDK">安装独立SDK</h4>
<p>下载<a href="http://developer.android.com/sdk/index.html" target="_blank">SDK</a></p>
<pre><code>tar zxvf path/<span class="keyword">to</span>/android<span class="attribute">-sdk_r21</span><span class="number">.0</span><span class="number">.1</span><span class="attribute">-linux</span><span class="built_in">.</span>tgz <span class="attribute">-C</span> ~/DevTools
cd ~/DevTools/android<span class="attribute">-sdk</span><span class="attribute">-linux</span>/tools<span class="subst">/</span>
<span class="built_in">.</span>/android sdk
</code></pre><h4 id="配置环境变量">配置环境变量</h4>
<p>在~/.bashrc或者/etc/environemnt</p>
<pre><code>export <span class="constant">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:~/DevTools/android-sdk-linux/tools/</span><span class="symbol">:~/DevTools/android-sdk-linux/platform-tools/</span>
</code></pre><h4 id="测试">测试</h4>
<pre><code>android list targets    <span class="comment">#查看可用平台</span>
android create <span class="keyword">project</span> –t <span class="number">1</span> –n MyFirstApp –p ~/Development/android-<span class="keyword">project</span>/MyFirstApp –a MainActivity –k com.example.myfirstapp
android avd   <span class="comment">#点击New，选择一个设备创建模拟器，完了点击Start启动模拟器 </span>
cd ~/DevTools/android-<span class="keyword">project</span>/MyFirstApp
ant debug   <span class="comment">#debug模式打包</span>
adb <span class="keyword">install</span> bin/MyFirstApp-debug.apk    <span class="comment">#用adb安装到模拟器</span>
</code></pre><p>具体教程参见<a href="http://developer.android.com/training/basics/firstapp/index.html" target="_blank">Building Your First App</a></p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Linux/" term="Linux"/>
    <category scheme="http://beforeload.github.io/tags/Ubuntu/" term="Ubuntu"/>
    <category scheme="http://beforeload.github.io/tags/Android/" term="Android"/>
    <category scheme="http://beforeload.github.io/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Building Node web Applications]]></title>
    <link href="http://beforeload.github.io/2013/06/10/building-node-web-applications/"/>
    <id>http://beforeload.github.io/2013/06/10/building-node-web-applications/</id>
    <published>2013-06-10T10:10:49.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Node-js网络应用开发">Node.js网络应用开发</h2>
<ol>
<li>Handling HTTP requests with Node’s API</li>
<li>Building a RESTful web service</li>
<li>Serving static files</li>
<li>Accepting user input from forms</li>
<li>Securing your application with HTTPS</li>
</ol>
<a id="more"></a>

<p>Node.js网络应用开发的简单图示如下：</p>
<img src="http://i.minus.com/iLMAoN6C3pEtN.png">


<h3 id="HTTP_server_的基本面">HTTP server 的基本面</h3>
<h4 id="HTTP请求在Node_HTTP_server中的生命周期">HTTP请求在Node HTTP server中的生命周期</h4>
<ol>
<li>HTTP 客户端（例如：浏览器）发送HTTP请求</li>
<li>Node进程接受到连接把请求的数据发送给HTTP server</li>
<li>Node进程把HTTP请求头完整解析，在’request’的回调事件中处理相应的逻辑</li>
<li>request的回调函数中体现应用的逻辑，例如产生一个response</li>
<li>请求通过HTTP server返回，这个过程会格式化成一个标准的HTTP response返回给客户端</li>
</ol>
<h3 id="Building_a_RESTful_web_service">Building a RESTful web service</h3>
<p>CURD: Creat, Update, Read, Delete<br>HTTP: Get, Post, Put, Delete</p>
<ol>
<li>使用POST创建资源</li>
<li>使用GET获取资源</li>
<li><p>使用DELETE删除资源</p>
<p> function(req, res){<br>   switch(req.method){<br>   case: ‘GET’: </p>
<pre><code> // to <span class="keyword">do</span>
 <span class="keyword">break</span>
</code></pre><p>   case: ‘POST’:</p>
<pre><code> // <span class="keyword">...</span>
 <span class="keyword">break</span>
</code></pre><p>   case: ‘DELETE’:</p>
<pre><code> // <span class="keyword">...</span>
 <span class="keyword">break</span>
</code></pre><p>   }<br> }</p>
</li>
</ol>
<h3 id="Serving_static_files">Serving static files</h3>
<ol>
<li>Get /index.html 用户向服务器请求一个静态文件</li>
<li>Node 服务器接受请求，应用的逻辑部分去读取这个文件</li>
<li>文件通过一个读取流的实例传递给服务器</li>
<li><p>文件的ReadStream通过’piped’拼接方式，以HTTP的response形式返回给客户端</p>
<p> …<br> var stream = fs.createReadStream(path)<br> // stream.on(‘data’, function(chunk){<br> //   res.write(chunk)<br> // })<br> // stream.on(‘end’, function(){<br> //   res.end()<br> // })<br> stream.pipe(res)<br> …</p>
</li>
</ol>
<p>相关的图片如下：</p>
<img src="http://i.minus.com/iOZW6WxLIsBNk.png">


<p>…<br>stream.pipe(res)<br>stream.on(‘error’,function(err){<br>  res.statusCode = 500<br>  res.end(‘Internal Server Error!’)<br>})<br>…</p>
<p>文件不存在错误处理”ENOENT, No such file or dictionary”</p>
<p>根据<code>fs.stat(path, function(err, stat){})</code>的err判断</p>
<h3 id="接受用户表单提交数据">接受用户表单提交数据</h3>
<ol>
<li>表单域</li>
<li>上传文件node-formidable</li>
<li>实时计算上传进度</li>
</ol>
<p>两种类型的表单提交</p>
<ul>
<li>“application/x-www-form-urlencoded”: the default for HTML forms</li>
<li>“multipart/form-data”: used when form contains files, non-ascii, or binary data</li>
</ul>
<p>node-formidable这个包可以帮助我们解决表单提交的绝大多数问题。<br>也可以计算伪实时的文件上传进度，如下所示：</p>
<pre><code>form.on(<span class="string">'process'</span>, <span class="function"><span class="keyword">function</span><span class="params">(bytesReceived, bytesExpected)</span>{</span>
    <span class="keyword">var</span> percent = bytesReceived / bytesExpected * <span class="number">100</span>
    console.log(percent)
})
</code></pre><p>剩下的就是将进度在前端页面上显示出来，利用如socket.io这样的实时模块可以轻松的搞定。我将在我的Repo: <a href="https://github.com/beforeload/node-upload" target="_blank">node-upload</a>中完成它。</p>
<h3 id="使用HTTPS_确保应用的安全性">使用HTTPS 确保应用的安全性</h3>
<p>生成一个私钥(加密)<br>    openssl genrsa 1024 &gt; key.pem</p>
<p>生成证书(解码)<br>    openssl req -x509 -new -key key.pem &gt; key-cert.pem</p>
<p><strong><em>HTTPS server选项</em></strong><br>    var https = require(‘https’)<br>      , fs = require(‘fs’)<br>      , options = {<br>        key: fs.readFileSync(‘./key.pem’),<br>        cert: fs.readFileSync(‘./key-cert.pem’)<br>      }</p>
<pre><code>https.createServer(options, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span></span>{
  res.writeHead(<span class="number">200</span>)
  res.<span class="keyword">end</span>(<span class="string">'Hello world!'</span>)
}).listen(<span class="number">4000</span>)
</code></pre><p>证书可以共享，它包括public key和持有者的身份信息。当然如果要发布一个网站，就需要在Certificate Authority(CA)上去注册，获取一个真实的，受信任的SSL证书。</p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Node.js/" term="Node.js"/>
    <category scheme="http://beforeload.github.io/categories/Node.js/" term="Node.js"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Priority Queue]]></title>
    <link href="http://beforeload.github.io/2013/05/30/priority-queue/"/>
    <id>http://beforeload.github.io/2013/05/30/priority-queue/</id>
    <published>2013-05-29T16:40:13.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>以6.5-1的数据作为输入 实现heapsort, 以及图解排序过程 </li>
<li>实现6.5-3所描述的最小优先级队列接口, 分析各接口所需的时间复杂度 </li>
<li>练习6.5-8 </li>
</ol>
<a id="more"></a>

<p>6.5-1 HEAP-EXTRACT-MAX</p>
<pre><code><span class="keyword">if</span> head-size[A] &lt; <span class="number">1</span>
    <span class="keyword">then</span> error
<span class="built_in">max</span> &lt;<span class="comment">-- A[1]</span>
A[<span class="number">1</span>] &lt;<span class="comment">-- heap-size[A] - 1</span>
MAX-HEAPIFY(A, <span class="number">1</span>)
<span class="constant">return</span> <span class="built_in">max</span>
</code></pre><img src="http://i.minus.com/imDBy99LrOzWP.jpg">


<p>6.5-3 HEAP-MINIUM(A)</p>
<p>伪代码书上已经有了</p>
<pre><code>HEAP-MINIMUM(<span class="literal">A</span>)
    <span class="keyword">return</span> <span class="literal">A</span>[<span class="number">1</span>]
</code></pre><p>利用HEAP-EXTRACT-MAX(A)容易写出HEAP-EXTRACT-MIN(A)</p>
<h4 id="HEAP-EXTRACT-MIN(A)">HEAP-EXTRACT-MIN(A)</h4>
<pre><code><span class="keyword">if</span> heap-size[<span class="literal">A</span>] &lt; <span class="number">1</span>
    then error 
max &lt;- <span class="literal">A</span>[<span class="number">1</span>]
<span class="literal">A</span>[<span class="number">1</span>] &lt;- <span class="literal">A</span>[heap-size[<span class="literal">A</span>]] - <span class="number">1</span>
heap-size[<span class="literal">A</span>] &lt;- heap-size[<span class="literal">A</span>] - <span class="number">1</span>
MIN-HEAPIFY(<span class="literal">A</span>, <span class="number">1</span>)
<span class="keyword">return</span> max
</code></pre><p>同样，由HEAD-INCREASE-KEY很容易就写出HEAD-DECREASE-KEY过程的伪代码：</p>
<h4 id="HEAD-DECREASE-KEY">HEAD-DECREASE-KEY</h4>
<pre><code><span class="keyword">if</span> key &gt; <span class="literal">A</span>[i]
    then error
<span class="literal">A</span>[i] &lt;- key
<span class="keyword">while</span> i &gt; <span class="number">1</span> <span class="literal">and</span> <span class="literal">A</span>[PARENT(i)] &gt; <span class="literal">A</span>[i]
    do exchange <span class="literal">A</span>[i] &lt;-&gt; <span class="literal">A</span>[PARENT(i)]
            i &lt;- PARENT(i)
</code></pre><p>同样，由MAX-HEAP-INSERT容易写出MIN-HEAP-INSERT</p>
<h4 id="MIN-HEAP-INSERT">MIN-HEAP-INSERT</h4>
<pre><code>heap-size[<span class="literal">A</span>] &lt;- heap-size[<span class="literal">A</span>] + <span class="number">1</span>
<span class="literal">A</span>[heap-size[<span class="literal">A</span>]] &lt;- 无穷
HEAP-INCREASE-KEY(<span class="literal">A</span>, heap-size[<span class="literal">A</span>], key)
</code></pre><p>6.5-8</p>
<p>每一个链表作为一个节点，链表的第一个元素作为key，然后组成一个堆，这个堆的大小为K(k个链表，k个节点)。</p>
<p>链表合并过程思路如下：</p>
<ol>
<li>通过堆的根节点，获得其链表的第一个元素</li>
<li>以获取的元素作为目标链表的尾端</li>
<li>因为根的第一个元素的key发生改变，对其进行MIN-HEAPFIY操作，递归进行下去。</li>
</ol>
<p>显然，在每个堆中取一个key组成的堆是实现此过程的一个最小堆。</p>
<p>具体的实现代码实在没有时间写了。</p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Algorithm/" term="Algorithm"/>
    <category scheme="http://beforeload.github.io/categories/Algorithm/" term="Algorithm"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Common Problems of Recommender Systems]]></title>
    <link href="http://beforeload.github.io/2013/05/27/common-problems-of-recommendation-systems/"/>
    <id>http://beforeload.github.io/2013/05/27/common-problems-of-recommendation-systems/</id>
    <published>2013-05-27T14:14:53.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h3 id="推荐系统的常见问题">推荐系统的常见问题</h3>
<h4 id="缺少大数据问题">缺少大数据问题</h4>
<p>Big data是推荐系统最关键的因素之一，对于推荐系统而言，可能最大的问题就是需要大规模的数据才能有效的进行推荐过程。这也毋庸置疑的表示那些拥有典型著名的推荐系统的公司恰恰是那些拥有大量消费者数据的公司：Google, Amazon, Netflix, Last.fm 。</p>
<a id="more"></a>

<h4 id="冷启动问题">冷启动问题</h4>
<p>在推荐系统的冷启动问题中，最主要包括两个方面：新用户问题，新资源问题。</p>
<p>(1) 新用户问题</p>
<p>这部分用户在系统中没有资源浏览访问记录，系统无法根据该用户行为数据对其浏览行为进行资源访问的预测和推推荐。</p>
<p>(2) 新资源问题</p>
<p>该部分资源没有用户的访问记录，使得系统在做数据分析时无法将其纳入待处理数据中，进而无法向用户推荐该资源。</p>
<h4 id="变化数据问题">变化数据问题</h4>
<p>推荐系统中的变化数据问题是指推荐系统中常常充斥着老的内容，新的数据资料等很难得到推荐。</p>
<h4 id="变化喜好问题">变化喜好问题</h4>
<p>在推荐系统中用户也许怀着不同的目的对于文件资源进行搜索浏览，及用户的喜好是变化跳跃的，系统很难对这种跳跃的喜好类别进行资源数据推荐。</p>
<h4 id="参考">参考</h4>
<p>(1) <a href="http://readwrite.com/2009/01/28/5_problems_of_recommender_systems" target="_blank">5 Problems of Recommender Systems</a><br>(2) <a href="http://www.resyschina.com/2010/03/five_problems_of_resys.html" target="_blank">推荐系统5大问题</a></p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Translate/" term="Translate"/>
    <category scheme="http://beforeload.github.io/tags/Distributed Computing/" term="Distributed Computing"/>
    <category scheme="http://beforeload.github.io/categories/Distributed Computing/" term="Distributed Computing"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Fix Some Ubuntu Problems]]></title>
    <link href="http://beforeload.github.io/2013/05/20/fix-some-problems/"/>
    <id>http://beforeload.github.io/2013/05/20/fix-some-problems/</id>
    <published>2013-05-20T14:10:58.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="解决_Ubuntu_13-04的视频音频相关问题">解决 Ubuntu 13.04的视频音频相关问题</h2>
<ol>
<li>Fix ASUS Webcam Problem:vertically flip my webcam’s image</li>
</ol>
<p><strong><em>问题描述</em></strong>：华硕电脑摄像头视频图像倒立</p>
<p>解决方法： 在google上搜索了一下 ubuntu camera invert找到几篇解决的博文，步骤如下：</p>
<a id="more"></a>

<p>(1) Install</p>
<pre><code><span class="variable">$echo</span> <span class="attribute">-e</span> <span class="string">"\n# libv4l PPA\ndeb http://ppa.launchpad.net/libv4l/ppa/ubuntu `lsb_release -c | awk '{print $2}'` main"</span> <span class="subst">|</span> sudo tee <span class="attribute">-a</span> /etc/apt/sources<span class="built_in">.</span><span class="built_in">list</span>

<span class="variable">$sudo</span> apt<span class="attribute">-key</span> adv <span class="subst">--</span>recv<span class="attribute">-keys</span> <span class="subst">--</span>keyserver keyserver<span class="built_in">.</span>ubuntu<span class="built_in">.</span>com C3FFB4AA

<span class="variable">$sudo</span> apt<span class="attribute">-get</span> update

<span class="variable">$sudo</span> apt<span class="attribute">-get</span> install libv4l<span class="subst">-</span><span class="number">0</span>
</code></pre><p>(2) Start application</p>
<pre><code><span class="variable">$export</span> <span class="constant">LIBV4LCONTROL_FLAGS</span>=<span class="number">3</span> &amp;&amp; cheese
<span class="variable">$export</span> <span class="constant">LIBV4LCONTROL_FLAGS</span>=<span class="number">3</span> &amp;&amp; <span class="constant">LD_PRELOAD</span>=<span class="regexp">/usr/lib</span><span class="regexp">/i386-linux-gnu/libv</span>4l/v4l1compat.so skype
</code></pre><p>为了以后不需要输入这么多，建立一个bash<br>Step 1:</p>
<pre><code><span class="variable">$sudo</span> gedit /usr/<span class="keyword">local</span>/bin/skype
</code></pre><p>填写下面内容</p>
<pre><code><span class="constant">LD_PRELOAD</span>=<span class="regexp">/usr/lib</span><span class="regexp">/i386-linux-gnu/libv</span>4l/v4l1compat.so /usr/bin/skype
</code></pre><p>Step 2:</p>
<pre><code>sudo chmod <span class="operator">a</span>+x /usr/<span class="built_in">local</span>/bin/skype
</code></pre><p><strong><em>注意</em></strong>：</p>
<ol>
<li><p>v4l1compat.so的位置在Ubuntu 13.04上可能和之前的版本不同，使用locate指令可以先确定一下位置。</p>
<p> $ locate v4l1compat.so<br> /usr/lib/i386-linux-gnu/libv4l/v4l1compat.so</p>
</li>
</ol>
<p><strong><em>参考</em></strong>：</p>
<p>(1) <a href="http://www.paullabis.com/2010/08/fix-upside-down-or-inverted-webcam-on.html" target="_blank">Fix upside-down or inverted webcam on Ubuntu linux</a></p>
<p>(2)<a href="http://community.linuxmint.com/tutorial/view/219" target="_blank">How to make Webcam compatible with Skype.</a></p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Ubuntu/" term="Ubuntu"/>
    <category scheme="http://beforeload.github.io/tags/Linux/" term="Linux"/>
    <category scheme="http://beforeload.github.io/categories/Linux/" term="Linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[inversion monge quicksort]]></title>
    <link href="http://beforeload.github.io/2013/05/17/inversion-monge-quicksort/"/>
    <id>http://beforeload.github.io/2013/05/17/inversion-monge-quicksort/</id>
    <published>2013-05-17T14:44:25.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="逆序对，Monge矩阵，快排优化——三数取中划分分析">逆序对，Monge矩阵，快排优化——三数取中划分分析</h2>
<h3 id="题目">题目</h3>
<ol>
<li>第二章思考题2-4(逆序对)</li>
<li>第四章思考题4-7(Monge矩阵)</li>
<li>第七章思考题7-5(快排的三数取中划分分析)</li>
</ol>
<a id="more"></a>

<h3 id="2-4_逆序对">2-4 逆序对</h3>
<p>a)</p>
<script src="https://gist.github.com/5599553.js?file=inversion.c"></script>


<p>结果: </p>
<p>(2,3)<br>(2,8)<br>(2,6)<br>(3,8)<br>(3,6)</p>
<p>b)</p>
<p>从1到n按倒序排列的数组含有最多的逆序对，<br>个数为(n-1)+(n-2)+…+1 = (n-1 + 1) <em> (n-1)/2 = n </em> (n-1)/2</p>
<p>c)</p>
<p>插入排序的运行时间与输入数组中逆序对的数量之间有怎样的关系?</p>
<p>当数组从小到大排序，插入排序算法复杂度最优为O(n),此时逆序对为0;</p>
<p>当数组从大到小排序，插入排序算法复杂度最坏情况，此时逆序对最多为n * (n-1)/2;</p>
<p>插入排序的过程如下：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">int</span> insert_sort(<span class="keyword">void</span>)
{
	<span class="keyword">int</span> i, j, key;
	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; i++) {
		key = arr[i];
		j = i;
		<span class="keyword">while</span> (j &gt; <span class="number">0</span> && arr[j - <span class="number">1</span>] &gt; key) {
			arr[j] = arr[j - <span class="number">1</span>];
			j--;
		}
	}
	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) {
		<span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);
	}
}
</pre></td></tr></table></figure>

<p>每多一个逆序对存在，就需要多一次比较，运行时间增加。插入排序每次比较后交换元素都是减少一对逆序对，循环本身是对所有的逆序对排序的过程。   </p>
<p>d)<br>O(nlg(n))修改合并排序，确定n个元素的任意排列中逆序对的数目。</p>
<script src="https://gist.github.com/5599593.js?file=inversion_d.c"></script>



<h3 id="Monge矩阵">Monge矩阵</h3>
<p>a)证明：当且仅当矩阵中所有2×2的矩阵都为Monge矩阵时，这个矩阵才为Monge矩阵。</p>
<p>先对行使用归纳法：假设i,k行j，l列矩阵为Monge矩阵，证明i,k+1行，j,l列矩阵为Monge矩阵即可</p>
<p>(1)已知i,k行j,l列为Monge矩阵即A[i,j]+A[k,l] &lt;= A[i,l] + A[k,j]<br>(2)假设A[k,j] + A[k+1,l] &lt;= A[k+1,j] + A[k,l]<br>(3)只需要证明i,k+1行j,l列的矩阵为Monge矩阵，<br>由(1),(2)得A[i,j] + A[k+1,l] &lt;= A[k,j] + A[k+1,l]                </p>
<p>对列用归纳法也是相同步骤，</p>
<p>已知A[i, j]+A[k, n] ≤ A[i, n]+A[k,j]<br>假设<br>A[i, n]+A[k,n+1] ≤ A[i, n+1]+A[k,n]<br>所以A[i, j]+A[k, n+1] ≤ A[i, n+1]+A[k, j]成立。                </p>
<p>行和列都满足归纳法，当<code>A[i,j]+A[i+1,j+1] &lt;= A[i,j+1] + A[i+1,j]</code>时，整个矩阵为Monge矩阵。               </p>
<p><strong>“仅当”</strong>这个条件用反正法可证。           </p>
<p>b) 利用a)的结论：<code>A[i,j] + A[i+1,j+1] &lt;= A[i,j+1]+A[i+1,j]</code>              </p>
<p>很容易得到矩阵第二行第三列到第三行第四列的2×2矩阵不满足条件;<br>所以只需要将第二行第三列的16和第三行第三列的22交换即可。             </p>
<p>c)<br>假设Monge矩阵中存在第x行和第x+1行，<code>f(x) &gt; f(x+1)  (1 &lt;= x &lt; m)</code>               </p>
<p>已知<code>A[x,f(x+1)] + A[x+1, f(x)] &lt;= A[x,f(x)] + A[x+1, f(x+1)]</code>                </p>
<p>又因为             </p>
<p>A[x,f(x)] &lt; A[x, f(x+1)]        (1)<br>A[x+1,f(x+1)] &lt;= A[x+1, f(x)]   (2)</p>
<p>(1) + (2) 得：                 </p>
<p>A[x,f(x+1)] + A[x+1, f(x)] &gt; A[x, f(x)] + A[x+1,f(x+1)]   (3)</p>
<p>根据a)结论，任意2×2矩阵都有</p>
<p>A[i,j] + A[i+1,j+1] &lt;= A[i,j+1]+A[i+1,j]      (4)</p>
<p>(3) 和 (4)矛盾，假设不成立。<br>由此可得：</p>
<p>f(1) &lt;= f(2) &lt;= … &lt;= f(m)            </p>
<p>d) 已知偶数行最左端最小值f(2), f(4), f(6), …<br>且f(2k) &lt;= f(2k+1) &lt;= f(2(k+1))</p>
<p>奇数行搜索一次，搜索范围为n列，偶数行重复计算两次</p>
<p>奇数行最左端最小值时间复杂度O(m/2+n)=O(m+n)<br>e)<br>由d)可得递归式：T(m) = T(m/2) + O(m+n)</p>
<p>递归运算结果：</p>
<p>T(m) = O(nlgm) + O(m+n)<br>     = O(nlgm + m + n)<br>     = O(nlgm + m)              </p>
<h3 id="快排中三数取中划分分析">快排中三数取中划分分析</h3>
<img src="//i.minus.com/i29Ufb20Oolkw.jpg" class="[inversion]">

<p>答案用图片显示，<a href="//i.minus.com/i29Ufb20Oolkw.jpg">图片在这里</a> </p>
<p>参考文章</p>
<ol>
<li><a href="//blog.csdn.net/zhanglei8893/article/details/6266915">“三数取中“划分</a></li>
</ol>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Algorithm/" term="Algorithm"/>
    <category scheme="http://beforeload.github.io/categories/Algorithm/" term="Algorithm"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[内容聚合Nodejs的实现]]></title>
    <link href="http://beforeload.github.io/2013/04/28/content-syndication-with-node.js/"/>
    <id>http://beforeload.github.io/2013/04/28/content-syndication-with-node.js/</id>
    <published>2013-04-28T02:16:15.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h3 id="[翻译]Content_Syndication_with_Node-js">[翻译]Content Syndication with Node.js</h3>
<hr>
<p>原文链接 <a href="http://howtonode.org/content-syndication-with-node" target="_blank">Content Syndication with Node.js</a></p>
<p>对于任何一个想和其他系统信息共享的网站而言，网络聚合是必须的。建议最好去了解一下RSS或者Atom之类的消息来源标准的格式规范，如果不采用一个处理这种格式的模块，生成这样的文本信息会是一件非常麻烦且耗时的工作。非常感谢<a href="https://npmjs.org/" target="_blank">NPM</a>，正由于nodejs的包管理工具的强大之处，自从有了它，再也不用担心生成自己的消息来源会耗费大量时间了。</p>
<a id="more"></a>

<h4 id="安装feed包">安装feed包</h4>
<p>  在开始之前，进入你的项目文件夹下，安装feed的最新版本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$npm</span> install feed
</pre></td></tr></table></figure>

<h4 id="建立订阅">建立订阅</h4>
<p>第一步：建立一个Feed(用来接收该信息来源更新的接口)的对象。当我们初始化这个对象的时候，提供我们网络聚合订阅的基本信息（这句话感觉怎么翻译怎么不通顺，我觉得就是根据我们了解的RSS或者Atom之类的格式，结合自己的网站提供相应信息）。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">// 需求的包</span>
varFeed<span class="subst">=</span><span class="keyword">require</span>(<span class="string">'feed'</span>);

<span class="comment">// 初始化feed对象</span>
<span class="built_in">var</span> feed <span class="subst">=</span>newFeed({
  title:          <span class="string">'My Feed Title'</span>,
  description:    <span class="string">'This is my personnal feed!'</span>,
  <span class="keyword">link</span>:           <span class="string">'http://example.com/'</span>,
  image:          <span class="string">'http://example.com/logo.png'</span>,
  copyright:      <span class="string">'Copyright © 2013 John Doe. All rights reserved'</span>,

  author:{
    name:       <span class="string">'John Doe'</span>,
    email:      <span class="string">'john.doe@example.com'</span>,
    <span class="keyword">link</span>:       <span class="string">'https://example.com/john-doe'</span>
  }
});
</pre></td></tr></table></figure>

<p>第二步：你可能希望区分自己的订阅专题。RSS和Atom标准格式都提供了一个或多个分类。当然，添加它们也超级简单：</p>
<p><code>feed.category(&#39;Node.js&#39;);
feed.category(&#39;JavaScript&#39;);</code></p>
<p>第三步：每个订阅都需要至少一个项目。（最好是一个入口）要做到这一点，你必须使用这些功能项目并提供合适的对象。当然，当你正在运行一个内容网站（就像你的博客），很可能发生的情况是你有多个项目。为了填充你的订阅信息，使用一个for循环，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>for(var key <span class="keyword">in</span> posts){
  feed<span class="preprocessor">.item</span>({
    title:  posts[key]<span class="preprocessor">.title</span>,
    link:  posts[key]<span class="preprocessor">.link</span>,
    description: posts[key]<span class="preprocessor">.description</span>,
    date: posts[key]<span class="preprocessor">.date</span>
  }
}
</pre></td></tr></table></figure>

<p>到这一步，生成RSS或者Atom标准的订阅的一切准备都已经OK了，使用下面的render方法</p>
<p><code>var output = feed.render()</code></p>
<p>这是含蓄的方式调用render请求。默认的是，它会渲染成RSS标准的订阅。你也可以使用这种含蓄的方式，选择RSS或者Atom</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// Rendering a RSS 2.0 valid feed</span>
feed.<span class="keyword">render</span>(<span class="string">'rss-2.0'</span>);

<span class="comment">// Rendering an Atom 1.0 valid feed</span>
feed.<span class="keyword">render</span>(<span class="string">'atom-1.0'</span>);
</pre></td></tr></table></figure>

<p>是的，就是这么简单！</p>
<p>feed结合 Express.js 一起会变得超级简单。告诉你一个使用app.get()方法去路由/rss路径。为了推送你的订阅，像我们之前提到的那样渲染我们的订阅。然后，把Content-type 设置成 text/xml：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre>app.get(<span class="string">'/rss'</span>,<span class="function"><span class="keyword">function</span><span class="params">(req, res)</span>{</span>
  <span class="comment">// Initializing feed object</span>
  <span class="keyword">var</span> feed =newFeed({
    title:          <span class="string">'My Feed Title'</span>,
    description:    <span class="string">'This is my personnal feed!'</span>,
    link:           <span class="string">'http://example.com/'</span>,
    image:          <span class="string">'http://example.com/logo.png'</span>,
    copyright:      <span class="string">'Copyright © 2013 John Doe. All rights reserved'</span>,

    author:{
      name:       <span class="string">'John Doe'</span>,
      email:      <span class="string">'john.doe@example.com'</span>,
      link:       <span class="string">'https://example.com/john-doe'</span>
    }
  });

  <span class="comment">// Function requesting the last 5 posts to a database. This is just an</span>
  <span class="comment">// example, use the way you prefer to get your posts.</span>
  Post.findPosts(<span class="function"><span class="keyword">function</span><span class="params">(posts, err)</span>{</span>
    <span class="keyword">if</span>(err)
      res.send(<span class="string">'404 Not found'</span>,<span class="number">404</span>);
    <span class="keyword">else</span>{
      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> posts){
        feed.item({
          title:          posts[key].title,
          link:           posts[key].url,
          description:    posts[key].description,
          date:           posts[key].date
        });
      }
      <span class="comment">// Setting the appropriate Content-Type</span>
      res.set(<span class="string">'Content-Type'</span>,<span class="string">'text/xml'</span>);

      <span class="comment">// Sending the feed as a response</span>
      res.send(feed.render(<span class="string">'rss-2.0'</span>));
    }
  });
});
</pre></td></tr></table></figure>


<h3 id="总结：">总结：</h3>
<p>就这样了，现在人们终于可以从你的nodejs应用中读取订阅你的项目。</p>
<p>译者：其实到这个地方还没有结束，本人在处理这个问题时感觉远远不想大神说的那么easy。有兴趣的最好自己尝试一下。</p>
<p>wrapper —— 包<br>feed —— 订阅<br>Feed —— 用来接收该信息来源更新的接口</p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Translate/" term="Translate"/>
    <category scheme="http://beforeload.github.io/tags/Node.js/" term="Node.js"/>
    <category scheme="http://beforeload.github.io/categories/Node.js/" term="Node.js"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Collaborative Markov Chain Model]]></title>
    <link href="http://beforeload.github.io/2013/04/22/collaborative-markov-chain-model/"/>
    <id>http://beforeload.github.io/2013/04/22/collaborative-markov-chain-model/</id>
    <published>2013-04-22T13:23:27.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="理论">理论</h2>
<h3 id="马尔可夫过程(Markov_Process)">马尔可夫过程(Markov Process)</h3>
<p>Markov过程是一个满足Markov性(无后效性)的随机过程。<br>具有马尔可夫性质的随机过程称为<strong>马尔可夫</strong>过程。[1]</p>
<p>最有名的Markov过程是Markov链，但还有其他的过程，如布朗运动，也是Markov过程。</p>
<a id="more"></a>

<h3 id="马尔可夫性质">马尔可夫性质</h3>
<p><strong>马尔可夫性质</strong>是概率论中的一个概念。当一个随即过程在给定状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是条件独立的，那么此随机过程具有<strong>马尔可夫性质</strong>。[2]</p>
<p>过程或（系统）在时刻t0所处的状态为已知的条件下，过程在时刻t&gt;t0所处状态的条件分布，与过程在时刻t0之前所处的状态无关的特性称为马尔可夫性或无后效性。[1]即：已知“现在”过程的情况下，“<em>将来</em>”过程的情况与“<em>过去</em>”的情况无关。</p>
<p>数学上，如果’X(t),t&gt;0’为一个随机过程，则马尔可夫性质就是指</p>
<img src="//upload.wikimedia.org/math/7/a/d/7ad721c51e3fd880f548cbfa67e80832.png" class="[img]">



<p>马尔可夫过程通常称其为<strong>（时间）齐次</strong>，如果满足</p>
<img src="//upload.wikimedia.org/math/1/a/9/1a97955e98197a3ef3212d0cfba0a752.png" class="[img]">


<p>则称为<strong>（时间)非齐次</strong></p>
<h3 id="马尔可夫链">马尔可夫链</h3>
<p><strong>定义：</strong></p>
<p>马尔可夫链是随机变量<em>X1,X2,X3…</em>的一个数列。这些变量的范围，即他们所有可能取值的集合，被称为“状态空间”，而Xn的值则是在时间的状态。</p>
<p>已知随机变量Xn是n时刻的状态，如果Xn+1对于过去状态的条件概率分布仅是Xn的一个函数，则</p>
<p><code>P(Xn+1=x|X0,X1,X2,…,Xn)=P(Xn+1=x|Xn), x为过程中的某个状态。</code></p>
<p>时间和状态都是离散的Markov过程称之为Markov链，简记为马氏链。</p>
<h3 id="马氏链的转移概率(Transition_probability)">马氏链的转移概率(Transition probability)</h3>
<p>在经过一段较长时间的状态转移后，Markov过程会逐渐趋于稳定状态，且与初始状态无关，称为终极状态概率，或平衡状态概率。此时，记终极状态概率向量为X=[x1,x2,…,xn],则有X=Xp,0&lt;=Xi&lt;=1(I=1,2，…,n)，可用于预测Markov过程在未来出现什么趋势的重要信息。目前多应用于统计，生物，地理统计学，人力资源，因特网应用等多个领域。</p>
<h3 id="Slope_one_协同过滤算法">Slope one 协同过滤算法</h3>
<p><strong>Slope One</strong> 是一系列应用于 协同过滤的算法的统称。由于它的简洁高效，并拥有不输于其他复杂算法的精确度，因此用它来改进Markov链模型。</p>
<p>简要说明一下，<strong>Slope One</strong>和大多评分算法类似并不适用于类似电子商务中，买家只提供买或者不买这样的二进制数据情况。</p>
<p>Slope One的一系列基于Item-based协同过滤算法，其本质上都是线性回归函数(f(x) = x + c)，好处是减少<strong>过适（过拟合）</strong>。对比于一个项目评分和另一个项目评分的线性回归（f(x) = ax + c），它只需要一半的存储量。也符合<strong><em>奥卡姆剃刀</em></strong>的原理：<strong>若无必要，勿增实体</strong>。</p>
<img src="//upload.wikimedia.org/wikipedia/commons/c/cb/Simplicity_diagram.png">


<ol>
<li>User A 对 Item I 评分为1 对Item J 评分为1.5</li>
<li>User B 对 Item I 评分为2</li>
<li>你认为 User B 会给 Item J 打几分?</li>
<li>Slope One 的答案是：2.5 (1.5-1+2=2.5).</li>
</ol>
<p>对“n”个项目，想要实现 <strong>Slope One</strong>，只需要计算并存储“n”对评分间的平均差值和评价数目即可。</p>
<h3 id="协同马尔可夫链模型">协同马尔可夫链模型</h3>
<p>使用改变的<strong>Slope One</strong>对数据进行初次协同过滤处理，并在此基础上结合Markov链模型对用户行为进行分析预测。在一个推荐系统中，推荐的准确性很大程度上取决于其基于的数据库的大小，数据量小的情况下，经常会遇到冷启动的问题（Cold boot problem），区别于计算机系统的冷启动（Cold Start），它包括两个方面，一方面是新指用户没有行为数据，无法根据历史行为，预测其兴趣爱好，另一方面是新资源没有访问记录，没有数据分析，无法向用户推荐。</p>
<p>使用协同马尔可夫链模型，可以相对准确的预测用户的兴趣，有效的减少冷启动的问题。</p>
<p>以上是理论部分，简单介绍了协同马尔可夫模型的一些理论依据，下面重点讲解其在用户行为分析中的应用与分析。</p>
<h3 id="参考文献：">参考文献：</h3>
<ol>
<li><a href="http://wiki.mbalib.com/wiki/马尔可夫过程" target="_blank">马尔可夫过程 - MBA智库百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/马尔可夫性质" target="_blank">马尔可夫性质- 维基百科，自由的百科全书 - 维基百科- Wikipedia</a></li>
</ol>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Math/" term="Math"/>
    <category scheme="http://beforeload.github.io/categories/Math/" term="Math"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Inverted Index in Hadoop]]></title>
    <link href="http://beforeload.github.io/2013/04/18/invertedindex-in-hadoop/"/>
    <id>http://beforeload.github.io/2013/04/18/invertedindex-in-hadoop/</id>
    <published>2013-04-18T04:26:32.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="倒排索引">倒排索引</h2>
<h3 id="简介:">简介:</h3>
<p>倒排索引是文档检索系统中最常用的数据结构，被广泛地应用于全文搜索引擎。它主要是用来存储某个单词(或词组)在一个文档或一组文档中的存储位置的映射，即提供了一种根据内容来查找文档的方式。由于不是更具文档来确定文档包含的内容，而是进行想法的操作，因而成为倒排索引(Inverted Index)。[1]</p>
<a id="more"></a>

<p>我的理解就是找到单词出现的文档的名称，多数情况下为一个列表。</p>
<p>一个单词可能在不同的文件中出现，所以我们需要定义一个权重，表示单词(即搜索的内容)跟文档的<strong><em>相关度</em></strong>。相关度的衡量多数情况下用<strong><em>词频</em></strong>来表示。</p>
<p>更加复杂的算法TF-IDF(Term Frequency-Inverse Document Frequency)统计单词在多少个文档中出现，甚至考虑单词在文档中出现的位置(例如标题处反应这个单词的重要性)。</p>
<p>理论的东西到此结束，下面写一下倒排索引的设计与实现。</p>
<h3 id="问题分析：">问题分析：</h3>
<p>信息的关键： <strong>单词</strong>，<strong>文档URI</strong>及<strong>词频</strong></p>
<h3 id="设计：">设计：</h3>
<h4 id="Map过程：">Map过程：</h4>
<p>TextInputFormat: 输入文件处理 -&gt; 文本每行的偏移量及其内容<br><code>&lt;key, value&gt;</code> =&gt;  单词，文档URI和词频<br>两个值对应三个值，需要增加Combine过程进行词频统计。</p>
<p><strong><em>key</em></strong>： <strong>单词:URI</strong> (例如：MapReduce:1.txt)<br><strong><em>value</em></strong>：<strong>词频</strong>，相同单词词频组成列表传递给Combiner过程，实现的功能类似于WordCount      </p>
<h4 id="Combine过程：">Combine过程：</h4>
<p>Combine过程会把相同的key值对应的value值累加<br>Map过程得到的结果为    </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="string">"MapRuduce:file01.txt"</span>  list<span class="function"><span class="params">(<span class="number">1</span>)</span>          =&gt;</span>     <span class="string">"MapReduce:file01.txt"</span>  <span class="number">1</span>    
<span class="string">"is:file01.txt"</span>         list<span class="function"><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span>        =&gt;</span>     <span class="string">"is:file01.txt"</span>         <span class="number">2</span>    
<span class="string">"powerful:file01.txt"</span>   list<span class="function"><span class="params">(<span class="number">1</span>)</span>          =&gt;</span>     <span class="string">"powerful:file01.txt"</span>   <span class="number">1</span>    
<span class="string">"simple:file01.txt"</span>     list<span class="function"><span class="params">(<span class="number">1</span>)</span>          =&gt;</span>     <span class="string">"simple:file01.txt"</span>     <span class="number">1</span>
</pre></td></tr></table></figure>

<p><strong><em>key</em></strong>： <strong>单词</strong><br><strong><em>value</em></strong>: <strong>URI:词频</strong>(如：1.txt:1)</p>
<p><strong>好处</strong>：可以利用MapReduce框架默认的HashPartitioner类完成Shuffle过程。</p>
<h4 id="Reduce过程：">Reduce过程：</h4>
<p>Combiner过程就已经把相同的单词的所有记录发送给同一个Reducer进行处理，Reduce过程就变得很简单，只需要将相同的key和value值组合成倒排索引文件所需的格式即可，剩下的交给MapReducer框架自动完成。</p>
<h4 id="问题">问题</h4>
<ol>
<li>文件数目;</li>
<li>文件大小;</li>
<li>Reduce过程没有统计词频，有可能会造成词频未统计完全的单词。    </li>
</ol>
<p><strong>备注及解决办法：</strong></p>
<ol>
<li>单个文件不宜过大，具体值与默认HDFS块大小及相关配置有关；</li>
<li>重写InputFormat类将每个文件作为一个split；</li>
<li>执行两次MapReduce，第一次统计词频，第二次MapReduce用于生成倒排索引。</li>
</ol>
<h4 id="优化思路：">优化思路：</h4>
<ol>
<li>利用复合键值对等实现包含更多信息的倒排索引。</li>
</ol>
<p><strong><strong>附Java源码：</strong></strong></p>
<script src="https://gist.github.com/5443748.js?file=InvertedIndex.java"></script>


<p><strong>参考：</strong><br>[1]. 《实战Hadoop》</p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Java/" term="Java"/>
    <category scheme="http://beforeload.github.io/tags/Hadoop/" term="Hadoop"/>
    <category scheme="http://beforeload.github.io/tags/Algorithm/" term="Algorithm"/>
    <category scheme="http://beforeload.github.io/tags/Distributed Computing/" term="Distributed Computing"/>
    <category scheme="http://beforeload.github.io/categories/Distributed Computing/" term="Distributed Computing"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[MapReduce]]></title>
    <link href="http://beforeload.github.io/2013/04/13/analyze-mapreduce/"/>
    <id>http://beforeload.github.io/2013/04/13/analyze-mapreduce/</id>
    <published>2013-04-12T18:56:30.000Z</published>
    <updated>2014-01-01T08:26:38.000Z</updated>
    <content type="html"><![CDATA[<p>写在前面的话：看了N多MapReduce方面的理论知识，一直想写写自己对MapReduce的理解。</p>
<h2 id="MapReduce_编程模型">MapReduce 编程模型</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="attribute">map</span>:<span class="function"><span class="params">(K1, V1)</span> -&gt;</span> list(K2, V2)
<span class="attribute">reduce</span>: <span class="function"><span class="params">(k2, list(V2))</span> -&gt;</span> list(K2, V2)
</pre></td></tr></table></figure>

<p>简而言之就是 <strong><em> 输入-&gt; Mappers -&gt; 中间数据 -&gt; Reducer -&gt; 输出 </em></strong> 这样的一个过程，把输入<code>(key, value)</code>经过map和reduce函数转换成另一个或一批<code>(key, value)</code>对输出即可。</p>
<a id="more"></a>

<h3 id="Mapper">Mapper</h3>
<p>Map阶段，MapReduce对任务输入数据分割，切割成固定大小的片段(splits)，对每个split进一步分解成一批键值对<code>(K1, V1)</code>。然后Hadoop为每个split创建Map任务(Mapper)，执行自定义的<code>map()</code>。</p>
<p>将split中的<code>(K1, V1)</code>键值对输入，得到结果为<code>(K2, V2)</code>的中间结果。<code>map()</code>的功能到这里并没有结束，因为我们在reduce阶段需要的输入格式是<code>(K2, list(V2))</code>，所以还需要对Mapper输出结果<code>(K2, V2)</code>进行合并(Combine过程)，即将中间结果中有相同key值(如：K2)的多组<code>(key, value)</code>对合并成一对(形成<code>(K2, list(V2))</code>)。key值范围决定了这些元组分组，对应不同的Reduce任务(Reducer)。</p>
<p><em>Tips:</em></p>
<ol>
<li>一个类作为mapper，要继承MapReduceBase基类并实现Mapper接口；</li>
<li>Mapper接口负责数据处理阶段。采用形式为<code>Mapper&lt;K1, V1, K2, V2&gt;</code> Java泛型；</li>
<li>Mapper只有一个方法——map，用于处理一个单独的键/值对。<figure class="highlight Java"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">void</span> map(K1 key, V1 value, OutputCollector&lt;K2, V2&gt; output, Reporter reporter)
    <span class="keyword">throws</span> IOException
</pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Reducer">Reducer</h3>
<p>Reduce阶段，数据整合，排序。然后调用自定义函数<code>reduce()</code>，输入<code>(K2, list(V2))</code>，得到键值对<code>&lt;K3, V3&gt;</code>输出到HDFS上。</p>
<p><em>Tips:</em></p>
<ol>
<li>Reducers数目在mapred-site.xml中决定，属性是<code>mapred.reduce.tasks</code>，默认值是 1，<code>job.setNumReduceTasks()</code>方法也可以用于设置，<strong>这是一个很重要的值</strong>；</li>
<li><p>reducer的实现首先必须在MapReduce基类上扩展，允许配置和清理。它必须实现Reducer接口实现<strong>reduce</strong>方法: </p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">void</span> reduce(K2 key, Iterator&lt;V2&gt; values, OutputCollector&lt;K3, V3&gt; output, 
        Reporter reporter) <span class="keyword">throws</span> IOException
</pre></td></tr></table></figure>
</li>
<li><p><code>reduce()</code>函数最后生成的列表<code>(K3, V3)</code>可能为空；</p>
</li>
<li>map阶段和reduce阶段中间还有partitioner的工作：负责将mapper的结果输出给不同的reducer。</li>
</ol>
<h3 id="Hadoop的MapReduce">Hadoop的MapReduce</h3>
<p>Hadoop框架的核心是Map和Reduce操作，但不仅仅如此，还包括：</p>
<p><strong><em> data spliting(数据分割), shuffling(洗牌), Partitioning(分组), Combining(合并) </em></strong></p>
<p>以及各种格式的输入输出数据。</p>
<h3 id="Shuffler">Shuffler</h3>
<p>Mapper的按key值分为R份(R即为上面说到的Reducers的数目)，划分时通常采用hash函数，如<code>Hash(key) mod R</code>。目的是保证某一范围内的key一定由某个Reducer来处理。</p>
<p><em>Tips:</em></p>
<ol>
<li>洗牌之后相同的key对应的键值对放入相同的Reducer，不同的键也可以放入相同的Reducer。具体放入的位置由Partitioner决定。</li>
</ol>
<h3 id="Partitioner:重定向Mapper输出">Partitioner:重定向Mapper输出</h3>
<p>并不是数据排序好就是最好的。利用并行计算，不能仅仅靠一个reducer，那样就不是“云”而是“雨点”。当多个reducer一起使用时，默认的做法是对键值对进行hash来确定reducer。</p>
<p><em>Tips:</em></p>
<ol>
<li>Hadoop通过HashPartitioner类强制执行Partitioner策略。但HashPartitioner有时会出错；</li>
<li>量身定制partitioner，只需要实现<code>configure()</code>和<code>getPartition()</code>两个函数，前者将Hadoop对作业的配置应用在patitioner上，后者返回一个0到reduce任务数之间的整数，指向键/值对将要发送到的reducer。</li>
</ol>
<h3 id="Combiner:_本地reduce">Combiner: 本地reduce</h3>
<p>合并Mapper输出，即将多个key相同的<code>&lt;key, value&gt;</code>合并成一对。Combine过程和Reduce过程类似，很多情况下可以直接使用reduce函数，但Combiner过程是Mapper的一部分，在map函数后执行。</p>
<p><em>Tips：</em></p>
<ol>
<li>Hadoop并不保证对一个Mapper执行多少次Combine过程，所以我们应该做到无论Combine过程执行多少次，得到结果都一样；</li>
<li>中间结果的读取，JobTracker介入，负责通知中间文件的位置；</li>
<li>Mapper输出结果不在HDFS上而在本地磁盘上，出于时效性考虑，任务结束后删除，而HDFS的备份机制会造成性能损失，没有必要。</li>
</ol>
<h3 id="讨论：">讨论：</h3>
<p>很多时候Rudecer产生的R个结果不是我们真正需要的最终结果，此时会把R个结果作为另一个计算的输入，开始另一个MapReduce任务，即任务管道。</p>
<h3 id="总结:">总结:</h3>
<p>MapReduce的集群行为(即MapReduce运行在大规模集群上的过程)，要完成一个并行计算，需要<em>_</em>任务调度与执行，本地计算，Shuffle，合并Mapper输出，读取中间结果，任务管道等一系列环节共同支撑计算的过程。</p>
]]></content>
    <category scheme="http://beforeload.github.io/tags/Hadoop/" term="Hadoop"/>
    <category scheme="http://beforeload.github.io/tags/MapReduce/" term="MapReduce"/>
    <category scheme="http://beforeload.github.io/categories/Distributed Computing/" term="Distributed Computing"/>
  </entry>
</feed>

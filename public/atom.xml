<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Daniel Liu]]></title>
  <subtitle><![CDATA[@beforeload]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://beforeload.github.io/"/>
  <updated>2014-12-23T09:26:05.590Z</updated>
  <id>http://beforeload.github.io/</id>
  
  <author>
    <name><![CDATA[Daniel Liu]]></name>
    <email><![CDATA[fe.daniel91@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[The Waterfall Flows Realization]]></title>
    <link href="http://beforeload.github.io/2014/09/03/The-Waterfall-Flows-Realization/"/>
    <id>http://beforeload.github.io/2014/09/03/The-Waterfall-Flows-Realization/</id>
    <published>2014-09-03T00:09:39.000Z</published>
    <updated>2014-11-08T15:37:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="瀑布流实现">瀑布流实现</h1>
<p><strong>要点：</strong></p>
<ol>
<li>布局计算</li>
<li>数据异步加载</li>
<li>resize</li>
<li>lazyload</li>
</ol>
<a id="more"></a>

<h2 id="1-_布局计算">1. 布局计算</h2>
<p>一般来说，瀑布流实现会有两种布局定位方式，一种通过 float 浮动定位，<br>另一种通过绝对定位方式计算。前者的好处是不需要大量计算，缺点是坑多，<br>如浏览器兼容性问题，以及 resize 过程，窗口缩小时，<br>元素浮动也会存在一些问题。而后者的优势在于对浏览器兼容性较好，<br>但是需要经过大量计算得出元素摆放的位置。<br>推荐的实现方式是使用第二种方式。</p>
<p>在实际开发中，考虑到需要浏览器需要适配的尺寸有 980px，1200px，1420px 三种尺寸。<br>但每个元素摆放的位置其实是有固定模式的，即算法是固定的。980px 宽度下，<br>瀑布流是4列，1200以上是五列。 所以需要定义一个变量来计算每列的最大高度。<br>其实这个高度是与绝对定位 top 值有关，这也是我们需要定义和设置的值。<br>而对于列变化和尺寸的关系可以自己定义。</p>
<h2 id="2-_数据异步加载">2. 数据异步加载</h2>
<p>瀑布流多多少少都会和 Ajax 异步加载结合使用，在某种程度上，<br>也给人一种无限刷新的快感。实现起来也颇为容易，主要有三点，主要是事件绑定，<br>请求时机， 发送请求渲染 DOM。</p>
<p>首先是事件绑定，监听的是浏览器 scroll 事件，这里面有个IE 的坑。<br>在 IE 浏览器中，在滚动过程中会多次触发 scroll 事件。可以通过<br>setTimeout 来解决。         </p>
<p>其次是请求的时机，请求的时机可以提前，也提倡提前，也就是说，<br>数据返回后渲染dom的时机要滞后，这样会有一种更加流畅的感觉。       </p>
<p>最后是发送请求，我们知道 Ajax 请求是异步的，而 scroll 过程中可能<br>多次触发，多次发送请求，可以建一个对象，用 hash 的方法<br>缓存请求去避免多次发送同样的请求。请求结果同时缓存起来，<br>直接塞到 Model 里即可。</p>
<p>具体请求的时机可以结合 clientHeight，pageHeight，scrollHeight 几个参数来设定。</p>
<h1 id="3-_resize">3. resize</h1>
<p>resize 的过程需要重新计算布局，这个过程可能产生一些好玩的情况。<br>重新计算布局和第一点所说的一致，不再赘述。<br>现在主流的分辨率适配需要980px，1200px，1420px 三种宽度尺寸，<br>而 resize 过程中瀑布流可能导致列数切换以及列宽变换。</p>
<h1 id="4-_lazyload">4. lazyload</h1>
<p>瀑布流一般用途也多用于图片展示上，图片的 lazyload 是一个可以有很大优化的空间。<br>lazyload在瀑布流上需要考虑的地方其实蛮多的。 例如图片请求的时机，<br>请求和渲染 View 异步进行。</p>
<p>思考：</p>
<p>对于瀑布流的数据到 View 的渲染过程，我采用了简单的 Model 到 View 的绑定，<br>对于复杂的应用场景多多少少有点捉襟见肘。我的实现思路是：写一个计算器，<br>对于每个 Model 放置的位置，直接计算后把结果存在 Model 中，Model 由于存放<br>过多的数据多多少少显得臃肿，但是好处是对 View 的渲染过程变得容易，以及对<br>resize 和 scroll 事件的处理也只需要把 Model 丢到计算器中重新计算，<br>并重用计算结果 Model 到 View 的绘制过程。</p>
]]></content>
    <summary type="html"><![CDATA[<h1 id="瀑布流实现">瀑布流实现</h1>
<p><strong>要点：</strong></p>
<ol>
<li>布局计算</li>
<li>数据异步加载</li>
<li>resize</li>
<li>lazyload</li>
</ol>
]]></summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[What is Inheritance in JavaScript]]></title>
    <link href="http://beforeload.github.io/2014/04/13/what-is-inheritance-in-javascript/"/>
    <id>http://beforeload.github.io/2014/04/13/what-is-inheritance-in-javascript/</id>
    <published>2014-04-13T10:20:55.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="理解JavaScript中的继承">理解JavaScript中的继承</h1>
<p>什么是继承？简而言之，父亲和儿子，儿子对父亲有继承关系。一句话能说明的关系在JavaScript中，使用起来并不容易。</p>
<p>从以下几个方面理解JavaScript的继承：</p>
<ol>
<li>类，对象和原型</li>
<li>类的定义</li>
<li>原型继承</li>
<li>构造函数继承</li>
<li>封装构造函数继承</li>
<li>复制继承</li>
</ol>
<a id="more"></a>

<h2 id="类，对象和原型">类，对象和原型</h2>
<p>JavaScript中继承机制其实一点都不复杂，JavaScript是基于对象的弱类型语言，以对象为基础，以函数为模型，以原型为继承机制。<br>对JavaScript的继承的理解，不能像Java或者其他语言的类继承一样去理解，而要理解原型继承。</p>
<p>首先理解原型。字面上理解，prototype是类的原型。作为构造函数的属性，一个对象拥有的原始的属性和方法都在prototype中。<br>也可以这样理解，对于守财奴的藏宝库，重要的宝贝都放在里面。prototype就相当于这样的一个藏宝室。<br>所以我们可以把prototype理解成一个数据集合，理解成一个指向宝藏的指针。</p>
<p>类是对象的模型化，而对象则是类和实例的关系演化，守财奴的父亲拥有一大笔财产（类是模型），他的每个儿子都对他的财产有继承权（对象继承）。<br>所以对于构造类（父亲）实例化的构造实例（儿子），构造实例（儿子）的原型对象（Prototype）指向了构造类（父亲）的原型属性（prototype）。</p>
<p>在JavaScript中没有传统意义上的类，而类的思想是用函数来模拟和表达。在控制台中可以体验一下下面的代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">}</div><div class="line"></div><div class="line">P.prototype.x = <span class="number">1</span>; <span class="comment">// 这里会被上面的属性x覆盖</span></div><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> P(<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> P();</div><div class="line">alert(s.x);  <span class="comment">// 10</span></div><div class="line">alert(s1.x);  <span class="comment">// undefined</span></div></pre></td></tr></table></figure>

<p>对象查询属性的顺序是最优先查询本地属性，如果没有查询对象本身的原型属性。因此，<br>虽然通过prototype设置了属性x的值，但是由于构造函数的原型属性和本地属性同名了，所以本地属性覆盖了原型属性。</p>
<p>JavaScript是动态的语言，设置原型的值会影响所有的实例。所以对上面的代码可以这样修改一下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span><span class="params">(x)</span></span>{      <span class="comment">//构造方法</span></div><div class="line">    <span class="keyword">if</span>(x) {</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">P.prototype.x = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> P();</div><div class="line">alert(s.x);   <span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> P(<span class="number">10</span>);</div><div class="line">alert(s1.x);  <span class="comment">// 10</span></div></pre></td></tr></table></figure>

<p>关于prototype属性的应用还有很多方面，比如说数据备份，设置只读属性，批量复制等，这里不一一赘述。</p>
<p>在JavaScript每个object都会有prototype属性，prototype指向另外的一个object对象。<br>通过上面的例子，我们可以知道，当我们需要读取一个object中某个属性x的时候，JavaScript引擎先查找这个object本身是否存在属性x。<br>如果不存在，才会查找这个object的prototype中是否存在属性x。</p>
<p>当我们new一个对象时，会给这个对象设置prototype属性，这个属性值来自它的构造函数的prototype属性值。<br>所有函数在定义时，就自动创建和初始化了prototype属性。这个prototype属性指向只包含constructor属性的对象，而constructor属性指向function本身。<br>因此，每一个object都会有一个constructor属性。</p>
<p>下面详细讲解以下类的定义的几种方式。</p>
<h2 id="类的定义">类的定义</h2>
<p>在JavaScript中，定义一个类通常有四种方式：</p>
<p>（1）工厂模式</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 减少重复创建函数的开销 */</span></div><div class="line"><span class="keyword">var</span> method = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    alert(<span class="keyword">this</span>.name + <span class="string">':'</span> + <span class="keyword">this</span>.age);</div><div class="line">}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> </span>{</div><div class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    p.name = name;</div><div class="line">    p.age = age;</div><div class="line">    p.what = method;</div><div class="line">    <span class="keyword">return</span> p; <span class="comment">// 初始化后的对象</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它是伪装的构造函数，不推荐使用。</p>
<p>(2) 构造函数模式</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'Daniel'</span>, <span class="number">22</span>);</div></pre></td></tr></table></figure>

<p>上面this指向当前实例对象。如果构造函数返回对象，那么返回的对象会覆盖this的值。如下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>(3) 原型模式</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> </span>{}</div><div class="line">Person.prototype.name = <span class="string">'Daniel'</span></div><div class="line">Person.prototype.age = <span class="number">22</span></div><div class="line">Person.prototype.what = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    alert(<span class="keyword">this</span>.title + <span class="string">': '</span> + <span class="keyword">this</span>.age);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>原型模式和构造函数模式的区别就是，构造函数模式的属性值是本地化的，而原型模式的属性值一旦更改，所有实例都会受到影响。</p>
<p>(4) 构造函数 + 原型模式</p>
<p>因为在原型模式不能轻易更改一个对象实例的属性值，而构造函数模式中又希望能够共享的使用一些属性和方法，所以引入“构造函数 + 原型模式”的混合设计。</p>
<p>如下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> </span>{    <span class="comment">// 构造函数的设计</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">}</div><div class="line"></div><div class="line">Person.prototype.what = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{    <span class="comment">// 原型模式设计</span></div><div class="line">    alert(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.age);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果我们希望遵循面向对象的设计原则，类成员都封装在类结构中，那么我们可以对构造函数原型模式进行加锁方式修改：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> Person.isLock == <span class="string">'undefined'</span>) {</div><div class="line">        Person.prototype.what = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">            alert(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.age);</div><div class="line">        }</div><div class="line">        Person.isLock = <span class="literal">true</span>;  <span class="comment">// 避免重复创建</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="原型继承">原型继承</h2>
<p>原型继承可以完全从对象角度来考虑，而淡化类和实例。因为在原型继承中，不用去定义类，直接定义对象，当对象被其他对象引用时，形成了继承关系。<br>这种继承关系可以通过原型链来查找。其中引用对象称为原型对象（object prototype）。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.x1 = x;</div><div class="line">    <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x1;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.x2 = x;</div><div class="line">    <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x2 + <span class="keyword">this</span>.x2;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">B.prototype = <span class="keyword">new</span> A(<span class="number">1</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.x3 = x;</div><div class="line">    <span class="keyword">this</span>.mul = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x3 * <span class="keyword">this</span>.x3;</div><div class="line">    }</div><div class="line">}</div><div class="line">C.prototype = <span class="keyword">new</span> B(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> C(<span class="number">3</span>);</div><div class="line">alert(b.x1);    <span class="comment">// 1</span></div><div class="line">alert(c.x1);    <span class="comment">// 1</span></div><div class="line">alert(c.mul()); <span class="comment">// 9</span></div><div class="line">alert(c.add()); <span class="comment">// 4</span></div></pre></td></tr></table></figure>

<p>原型继承是直接复制已经存在的原型对象实现继承关系，基于原型而没有类的概念。不能很好的支持多参数和动态参数的父类。<br>结构简单，不支持多重继承，不够灵活，原型声明的同时需要实例化父类对象，限制了父类实例化的灵活性。</p>
<h2 id="构造函数继承">构造函数继承</h2>
<p>众所周知，构造函数也是函数的一种，只是比普通函数特殊一点而已。<br>当我们把构造函数A的方法赋值给构造函数B，然后调用该方法，构造函数A在B的内部执行，这时，B的内部就拥有了构造函数A中定义的属性和方法。<br>这种B继承A的实现过程跟传统的类继承还是非常相似的。所以在一些书籍中，这样的继承也成为类继承。</p>
<p>请看下面的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 构造函数A */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        alert(<span class="keyword">this</span>.x);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* 构造函数B */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(x, y)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.m = A;</div><div class="line">    <span class="keyword">this</span>.m(x);</div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.m;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">    <span class="keyword">this</span>.call = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">        alert(<span class="keyword">this</span>.y);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Tester */</span></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line">a.say();    <span class="comment">// 1</span></div><div class="line">b.say();    <span class="comment">// 2 这里说明继承成功</span></div><div class="line">b.call();   <span class="comment">// 3</span></div></pre></td></tr></table></figure>

<p>上面的写法是不是感觉很难受，需要定义一个临时的方法<code>m()</code>，构造函数参数x传递给构造函数A，执行后又把临时方法删除，实在是有种卸磨杀驴的味道。<br>将父类的构造函数绑定在子类的构造函数上，可以使用call或者apply方法，推荐下面的写法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(x, y)</span> </span>{</div><div class="line">    A.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">    <span class="keyword">this</span>.call = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        alert(<span class="keyword">this</span>.y);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>即使这样优化后，还是欠妥，因为这样的构造函数继承中相互耦合性太高，不能适用复杂的编程中。</p>
<p>所以在构造函数继承中，引入prototype是很有必要的，请看下面的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">(x)</span></span>{</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">}</div><div class="line"></div><div class="line">A.prototype.getx = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(x, y)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">    A.call(<span class="keyword">this</span>, x);</div><div class="line">}</div><div class="line"></div><div class="line">B.prototype = <span class="keyword">new</span> A();  <span class="comment">// 这个时候 B.prototype.constructor指向了A</span></div><div class="line">B.prototype.constructor = B;</div><div class="line">B.prototype.gety = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line">alert(b.getx());</div><div class="line">alert(b.gety());</div></pre></td></tr></table></figure>

<p>在原型继承中，在为B类的原型赋值为A类的实例前，所以定义的任何属性和方法都将会被覆盖。<br>扩展B类的原型方法，要在原型绑定之后，再定义扩展方法。</p>
<h2 id="封装构造函数继承">封装构造函数继承</h2>
<p>了解上面的构造函数继承后，我们可以定义一个形式如下的封装函数，帮助我们处理子类和超类的继承模式。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(Sub, Sup)</span> </span>{ <span class="comment">// Sub 子类，Sup 超类</span></div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};    <span class="comment">// 这是一个空函数</span></div><div class="line">    F.prototype = Sup.prototype;</div><div class="line">    Sub.prototype = <span class="keyword">new</span> F();</div><div class="line">    Sub.prototype.constructor = Sub;</div><div class="line">    Sub.sup = Sup.prototype;</div><div class="line">    <span class="comment">/* 检测超类的原型构造器是否与Object的原型构造器发生耦合 */</span></div><div class="line">    <span class="keyword">if</span>(Sup.prototype.constructor == <span class="built_in">Object</span>.prototype.constructor) {</div><div class="line">        Sup.prototype.constructor = Sup;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>值得注意的是上面的函数输入是子类和超类对象，没有输出。空函数F的作用是中转作用，F的原型为超类的原型，F的实例作为子类的原型。<br>这样做的好处是如果超类自身规模较大，直接实例化超类占用内存较大，对系统负荷较大。</p>
<p>对于上面封装函数的实现，我们可以用下面的例子来测试一下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">A.prototype.double = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x * <span class="number">2</span>;</div><div class="line">}</div><div class="line">A.prototype.mul = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x * <span class="keyword">this</span>.x;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">(x)</span> </span>{</div><div class="line">    A.call(<span class="keyword">this</span>, x);    <span class="comment">// 内部数据绑定</span></div><div class="line">}</div><div class="line"></div><div class="line">extend(B, A);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="number">2</span>);</div><div class="line">alert(b.get());     <span class="comment">// 2</span></div><div class="line">alert(b.double());  <span class="comment">// 4</span></div><div class="line">alert(b.mul());     <span class="comment">// 4</span></div><div class="line">B.prototype.double = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="string">''</span> + <span class="keyword">this</span>.x;</div><div class="line">}</div><div class="line">alert(b.double());     <span class="comment">// '22' 字符串</span></div></pre></td></tr></table></figure>

<p>B类新定义的add方法会覆盖A类的同名方法。在B类的原型方法double()中可以调用A类的原型方法double()，从而避免代码耦合。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">B.prototype.double = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">return</span> B.sup.double.call(<span class="keyword">this</span>);     <span class="comment">// 内部调用</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="复制继承">复制继承</h2>
<p>之所以提一下复制继承，是因为这是继承的最原始的方法，它的思路也非常清晰：利用for in去遍历对象属性赋值给新的对象，<br>这种思路常常让我想起作业抄袭答案的场景。下面封装一个复制继承的函数：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(p, copy)</span> </span>{</div><div class="line">    <span class="keyword">var</span> copy = copy || {};</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> p) {</div><div class="line">        <span class="keyword">if</span>((<span class="keyword">typeof</span> p[i]).toString().toLowerCase() === <span class="string">'object'</span>) {</div><div class="line">            copy[i] = (p[i].constructor === <span class="built_in">Array</span>) ? []: {};</div><div class="line">            extend(p[i], copy[i]);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            copy[i] = p[i];</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> copy;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也有人说这样的拷贝思路是深拷贝，因为他对数组和对象进行了递归处理。<br>jQuery貌似也是用这种方式实现继承方法的。</p>
<p>针对上面的继承函数，下面简单测试一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = {</div><div class="line">    name: <span class="string">'A'</span></div><div class="line">}</div><div class="line"></div><div class="line">A.arr = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// 这个要写在extend()前面</span></div><div class="line"><span class="keyword">var</span> B = extend(A);</div><div class="line">B.arr.push(<span class="number">3</span>)</div><div class="line">alert(A.arr);   <span class="comment">// 1,2</span></div><div class="line">alert(B.arr);   <span class="comment">// 1,2,3</span></div></pre></td></tr></table></figure>

<p>在另外一本书上我看到了这样的封装方法，仅供参考：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">FUnction.prototype.extend = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span>{</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o) {</div><div class="line">        <span class="keyword">this</span>.constructor.prototype[i] = o[i];</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Test */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">(x, y)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">    <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</div><div class="line">    }</div><div class="line">}</div><div class="line">F.prototype.mul = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x * <span class="keyword">this</span>.y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> o = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};</div><div class="line">o.extend(<span class="keyword">new</span> F(<span class="number">2</span>, <span class="number">3</span>));</div></pre></td></tr></table></figure>

<p>这段代码其实是通过反射机制，复制类对象的所有可枚举的属性和方法来模拟继承。对这段代码可以进行优化如下：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.clone = <span class="function"><span class="keyword">function</span><span class="params">(o)</span> </span>{</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Temp</span><span class="params">()</span> </span>{};</div><div class="line">    Temp.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Temp();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = <span class="built_in">Function</span>.clone(<span class="keyword">new</span> F(<span class="number">2</span>, <span class="number">3</span>));</div><div class="line">alert(o.x);         <span class="comment">// 2</span></div><div class="line">alert(o.y);         <span class="comment">// 3</span></div><div class="line">alert(o.add());     <span class="comment">// 5</span></div><div class="line">alert(o.mul());     <span class="comment">// 6</span></div></pre></td></tr></table></figure>

<h2 id="小结">小结</h2>
<p>对JavaScript的语言来说，要了解的东西还是很多，继承只是其中冰山一角。<br>JavaScript的继承尽管多样化，相比较Java而言还是优雅而简洁的（不忘记黑一下Java）。<br>希望这篇文章能够对你有所帮助，写了很多废话，如果有什么不当的地方，请务必告诉我，非常感谢！</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://book.douban.com/subject/20366358/" target="_blank" rel="external">编写高质量代码</a></li>
<li><a href="http://www.crockford.com/javascript/inheritance.html" target="_blank" rel="external">Classical Inheritance in JavaScript</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">阮一峰的网络日志</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<h1 id="理解JavaScript中的继承">理解JavaScript中的继承</h1>
<p>什么是继承？简而言之，父亲和儿子，儿子对父亲有继承关系。一句话能说明的关系在JavaScript中，使用起来并不容易。</p>
<p>从以下几个方面理解JavaScript的继承：</p>
<ol>
<li>类，对象和原型</li>
<li>类的定义</li>
<li>原型继承</li>
<li>构造函数继承</li>
<li>封装构造函数继承</li>
<li>复制继承</li>
</ol>
]]></summary>
    
      <category term="JavaScript" scheme="http://beforeload.github.io/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://beforeload.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Closure of JavaScript]]></title>
    <link href="http://beforeload.github.io/2014/01/03/closure-of-javascript/"/>
    <id>http://beforeload.github.io/2014/01/03/closure-of-javascript/</id>
    <published>2014-01-03T14:17:17.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaScript_中的闭包">JavaScript 中的闭包</h1>
<p>这篇文章写的较早，而且内容太水，建议不要浪费时间去阅读它。有时间我会重写一下。</p>
<a id="more"></a>

<p>最近被人问到JavaScript中闭包的作用，无意中回忆起很久之前实习面试的时候也被问过类似的问题，想起在写JS中遇到的一些习惯性的问题，写篇博客总结一下。</p>
<h2 id="作用域">作用域</h2>
<p>我感觉很多JS开发人员在对作用域的了解上都存在错误，虽然JavaScript是一种类C 的语言，但它并不支持块级作用域，块级作用域是定义在代码块中的变量在代码块执行结束后会被释放掉。</p>
<p>在JavaScript中，则是通过函数作用域的方式，函数中的参数和变量在函数外不可见，而函数内自由使用，即内部任意位置定义的变量在函数内部任何地方都可见，当然定义变量时，请用var。为了避免块级作用域可能产生的问题，可以在函数体的顶部声明函数可能用到的所有变量。这也是很多前端开发人员的一个很好的习惯。</p>
<h2 id="闭包的产生">闭包的产生</h2>
<p>根据上面对作用域的描述，函数体内部可以访问外部函数的参数和变量（当然不包括this和arguments），这也叫做链式作用域(chain scope)。理解了作用域，闭包就变得很好理解了，我觉得可以这样简单的去理解它：一个定义在函数内部的函数，它可以访问创建时所处的上下文环境。这是最浅显的理解，当然它的作用远不止这些。</p>
<h2 id="闭包的作用">闭包的作用</h2>
<p>一个闭包最重要的作用不仅仅是可以读取函数内部的变量，更让人惊喜的是，<em>只要内部函数需要</em>，这些变量的值在内存中会一直存在。可以在控制台中写个简单的例子来演示它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add</div><div class="line">function a() {</div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span></div><div class="line">    add = function () {</div><div class="line">        x += <span class="number">1</span></div><div class="line">    }</div><div class="line"></div><div class="line">    function b() {</div><div class="line">        console.log(x)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> b</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> <span class="literal">result</span> = a()</div><div class="line"><span class="literal">result</span>() // <span class="number">1</span></div><div class="line">add()</div><div class="line"><span class="literal">result</span>() // <span class="number">2</span></div></pre></td></tr></table></figure>

<p>值得注意的是上面的例子中有两个闭包，add是一个匿名函数，也是一个闭包，它在函数外部定义，却在操作函数内部的变量。result是闭包b的函数，两次运行的值不同表示x值在内存中一直保存着，a调用结束后，x没有被回收。</p>
<p>如果上面例子理解有困难，那我们来简化它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span> </span>{</div><div class="line">        x += <span class="number">1</span></div><div class="line">        <span class="built_in">console</span>.log(x)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> b  <span class="comment">// 注意，这个地方非常重要</span></div><div class="line">}</div><div class="line"><span class="keyword">var</span> s = a()</div><div class="line">s() <span class="comment">// 2</span></div><div class="line">s() <span class="comment">// 3</span></div></pre></td></tr></table></figure>

<p>现在只有一个闭包函数，这下子可以一眼看出来了吧。函数b嵌套在函数a内，函数a返回函数b。当函数b在函数a外部的一个变量引用时，就产生了闭包。</p>
<p>当然，由于长期保存在内存中不能释放，很多人也会遇到JavaScript内存泄露的问题(IE中)，这需要我们小心的使用闭包。有经验的前端工程师给出的建议是在推出函数之前，删除不使用的局部定义的变量。</p>
<h2 id="理解闭包">理解闭包</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span></div><div class="line"><span class="keyword">var</span> object = {</div><div class="line">    name: <span class="string">"My Object"</span>,   </div><div class="line">    getNameFunc: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{   </div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{   </div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">        }   </div><div class="line">    }   </div><div class="line">}</div><div class="line"><span class="built_in">console</span>.log(object.getNameFunc()())</div></pre></td></tr></table></figure>

<p>猜猜结果会是什么？<br>答案是：”The Window”</p>
<p>很显然，闭包函数在<code>getNameFunc</code>函数外部被调用，那么<code>this</code>就不指向<code>object</code>对象，而指向了全局的<code>window</code>，所以最后的结果是<code>window.name</code>，也就是”The Window”</p>
<p>通过闭包，我们可以很显然的观察到函数的<em>定义</em>和<em>执行</em>过程。使用闭包，一方面可以保护函数内变量的安全，实现私有属性和私有方法的作用，另一方面可以在内存中保持一个变量。</p>
<h2 id="JS中的GC机制">JS中的GC机制</h2>
<p>这里延伸一点，解释一下为什么产生闭包时，内部函数会比外部函数拥有更长的生命周期。这是由JS中的GC机制决定的。</p>
<p>在JavaScript中，如果一个对象不再被引用，那么这个对象就被GC回收。如果两个对象相互引用，但不会被第三个对象引用时，这两个对象都会被回收。但是，如果函数a被b引用，b又被函数a外的c引用，这样函数a执行完之后，却不会被回收了。</p>
<p>写在最后的话：关于闭包的东西远远不止这些，使用方式也复杂多样，但是万变不离其宗，理解它的机制可以帮助我们写出更加高效优雅的代码。</p>
]]></content>
    <summary type="html"><![CDATA[<h1 id="JavaScript_中的闭包">JavaScript 中的闭包</h1>
<p>这篇文章写的较早，而且内容太水，建议不要浪费时间去阅读它。有时间我会重写一下。</p>
]]></summary>
    
      <category term="JavaScript" scheme="http://beforeload.github.io/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://beforeload.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim Powerline installation on Ubuntu 13.10]]></title>
    <link href="http://beforeload.github.io/2014/01/02/vim-powerline-installation-on-ubuntu-1310/"/>
    <id>http://beforeload.github.io/2014/01/02/vim-powerline-installation-on-ubuntu-1310/</id>
    <published>2014-01-02T04:53:58.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Ubuntu_13-10上安装vim-powerline">在Ubuntu 13.10上安装vim-powerline</h1>
<p> 最近又重装了一次ubuntu，发现在ubuntu上每次都要去找<code>vim-powerline</code>的安装及配置太麻烦，而Ubuntu上的字体每次都需要使用fontpather打一次补丁，不然<code>let g:Powerline_symbols = &#39;fancy&#39;</code>没有效果，下面的箭头无法显示出来。所以整理这篇博客，记录配置过程的一些问题和解决方法。</p>
<img src="http://i.stack.imgur.com/T6APG.png" title="Vim Powerline Normal"><br><img src="http://i.stack.imgur.com/4R3XS.png" title="Vim Powerline Insert"><br><img src="http://i.stack.imgur.com/VTB31.png" title="Vim Powerline Visual"><br><img src="http://i.stack.imgur.com/HhgMo.png" title="Vim Powerline Replace">

<a id="more"></a>

<h2 id="一、安装Powerline">一、安装Powerline</h2>
<ol>
<li>首先安装python-pip和git:</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="built_in">get</span> install <span class="keyword">python</span>-pip git</div></pre></td></tr></table></figure>

<ol>
<li>安装Powerline</li>
</ol>
<p>分两种情况：<br>1) 对于个人用户</p>
<p>在控制台中运行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install --user git+gi<span class="variable">t:</span>//github.<span class="keyword">com</span>/Lokaltog/powerline</div></pre></td></tr></table></figure>

<p>修改<code>~/.profile</code>，将<code>~/.local/bin</code>加到<code>$PATH</code>中，在末尾加上：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ <span class="operator">-d</span> <span class="string">"<span class="variable">$HOME</span>/.local/bin"</span> ]; <span class="keyword">then</span></div><div class="line">    PATH=<span class="string">"<span class="variable">$HOME</span>/.local/bin:<span class="variable">$PATH</span>"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>

<p>2) 对于系统用户</p>
<p>在控制台中运行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su -c 'pip install git+git:<span class="comment">//github.com/Lokaltog/powerline'</span></div></pre></td></tr></table></figure>

<h2 id="二、字体的安装">二、字体的安装</h2>
<p>对于Ubuntu的用户来说，安装字体再简单不过了，只需要双击文件，点击Install即可。这里不在赘述。</p>
<p>不过，我发现从<a href="https://github.com/Lokaltog/powerline-fonts" target="_blank" rel="external">powerline-fonts</a>上下载的字体不能直接用，还是需要配置，配置过程如下：</p>
<ol>
<li>Fontconfig：(推荐)</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="built_in">get</span> install fontforge <span class="keyword">python</span>-fontforge</div></pre></td></tr></table></figure>

<p>1) 对于个人用户</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> ~/.fonts/ && <span class="keyword">cd</span> ~/.fonts/</div><div class="line">wget http<span class="variable">s:</span>//github.<span class="keyword">com</span>/Lokaltog/powerline/raw/develop/font/PowerlineSymbols.otf </div><div class="line">wget http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/Lokaltog/powerline-fonts/master/SourceCodePro/Sauce%<span class="number">20</span>Code%<span class="number">20</span>Powerline%<span class="number">20</span>Black.otf</div><div class="line">~/.<span class="keyword">vim</span>/bundle/<span class="keyword">vim</span>-powerline/fontpatcher/fontpatcher *.otf</div><div class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> ~/.config/fontconfig/<span class="keyword">conf</span>.<span class="keyword">d</span>/ <span class="keyword">cd</span> ~/.config/fontconfig/<span class="keyword">conf</span>.<span class="keyword">d</span>/ </div><div class="line">wget http<span class="variable">s:</span>//github.<span class="keyword">com</span>/Lokaltog/powerline/raw/develop/font/<span class="number">10</span>-powerline-symbols.<span class="keyword">conf</span></div><div class="line">fc-cache -vf ~/.fonts</div></pre></td></tr></table></figure>

<p>2) 对于系统用户</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wget http<span class="variable">s:</span>//github.<span class="keyword">com</span>/Lokaltog/powerline/raw/develop/font/PowerlineSymbols.otf</div><div class="line">wget http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/Lokaltog/powerline-fonts/master/SourceCodePro/Sauce%<span class="number">20</span>Code%<span class="number">20</span>Powerline%<span class="number">20</span>Black.otf</div><div class="line">wget http<span class="variable">s:</span>//github.<span class="keyword">com</span>/Lokaltog/powerline/raw/develop/font/<span class="number">10</span>-powerline-symbols.<span class="keyword">conf</span></div><div class="line">/etc/<span class="keyword">vim</span>/bundle/<span class="keyword">vim</span>-powerline/fontpatcher/fontpatcher *.otf</div><div class="line">sudo mv *.otf /usr/share/fonts/</div><div class="line">sudo fc-cache -vf</div><div class="line">sudo mv <span class="number">10</span>-powerline-symbols.<span class="keyword">conf</span> /etc/fonts/<span class="keyword">conf</span>.<span class="keyword">d</span>/</div></pre></td></tr></table></figure>

<p>如果嫌麻烦，后面有我的打过补丁的字体可以直接下载使用。</p>
<h2 id="三、配置-vimrc">三、配置.vimrc</h2>
<ol>
<li>Vim状态栏的配置</li>
</ol>
<p>在<code>~/.vimrc</code>或者<code>/etc/vim/vimrc</code>文件中进行配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></div><div class="line"><span class="keyword">set</span> fillchars+=stl:\ ,stlnc:\</div><div class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span></div><div class="line"><span class="keyword">set</span> rtp+=$HOME/.local/<span class="keyword">lib</span>/python2<span class="number">.7</span>/site-packages/powerline/bindings/vim/</div><div class="line"><span class="keyword">set</span> -g <span class="keyword">default</span>-terminal <span class="string">"screen-256color"</span></div><div class="line"><span class="keyword">set</span> t_Co=<span class="number">256</span></div><div class="line"><span class="keyword">let</span> g:Powerline_symbols = <span class="comment">'fancy'</span></div></pre></td></tr></table></figure>

<p>后面附上我的vimrc相关配置。</p>
<h2 id="四、卸载">四、卸载</h2>
<p>1) 对于个人用户：</p>
<pre><code>pip <span class="operator"><span class="keyword">uninstall</span> powerline</span>
</code></pre><p>2) 对于系统用户：</p>
<pre><code><span class="title">su</span> -c <span class="string">'pip uninstall powerline'</span>
</code></pre><h3 id="附上我的字体配置文件">附上我的字体配置文件</h3>
<ol>
<li><a href="https://github.com/beforeload/dotfiles/tree/master/fonts" target="_blank" rel="external">字体</a></li>
<li><a href="https://raw.github.com/beforeload/dotfiles/master/.vimrc" target="_blank" rel="external">.vimrc</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<h1 id="在Ubuntu_13-10上安装vim-powerline">在Ubuntu 13.10上安装vim-powerline</h1>
<p> 最近又重装了一次ubuntu，发现在ubuntu上每次都要去找<code>vim-powerline</code>的安装及配置太麻烦，而Ubuntu上的字体每次都需要使用fontpather打一次补丁，不然<code>let g:Powerline_symbols = &#39;fancy&#39;</code>没有效果，下面的箭头无法显示出来。所以整理这篇博客，记录配置过程的一些问题和解决方法。</p>
<img src="http://i.stack.imgur.com/T6APG.png" title="Vim Powerline Normal"><br><img src="http://i.stack.imgur.com/4R3XS.png" title="Vim Powerline Insert"><br><img src="http://i.stack.imgur.com/VTB31.png" title="Vim Powerline Visual"><br><img src="http://i.stack.imgur.com/HhgMo.png" title="Vim Powerline Replace">

]]></summary>
    
      <category term="Linux" scheme="http://beforeload.github.io/tags/Linux/"/>
    
      <category term="Vim" scheme="http://beforeload.github.io/tags/Vim/"/>
    
      <category term="Linux" scheme="http://beforeload.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Introduction to Machine Learning]]></title>
    <link href="http://beforeload.github.io/2013/10/19/introduction-to-machine-learning/"/>
    <id>http://beforeload.github.io/2013/10/19/introduction-to-machine-learning/</id>
    <published>2013-10-19T12:25:13.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="机器学习简介">机器学习简介</h2>
<h3 id="一、定义">一、定义</h3>
<blockquote>
<p>Arthur Samuel (1959): Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed.<br>Tom Mitchell (1998) : Well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.</p>
</blockquote>
<a id="more"></a>

<p>个人理解，一句话就是不通过明确的编程让机器具有学习能力，以垃圾邮件为例：</p>
<ol>
<li>邮件分为垃圾邮件和非垃圾邮件为任务T；</li>
<li>查看哪些邮件被标记为垃圾邮件，以及哪些标记为非垃圾邮件是经验E；</li>
<li>正确识别垃圾邮件或非垃圾邮件比例（或数量）为P。</li>
</ol>
<h3 id="二、机器学习算法的类型">二、机器学习算法的类型</h3>
<p>(1) 监督学习(Supervised learning)</p>
<ol>
<li>概念： 通过生成一个函数将输入映射为一个合适的输出（通常也称为标记，多数情况下训练集都是有人工专家标注生成的）。</li>
<li>理解： 通过分好类的输入，模拟出一个函数，以预测相应的结果产生的概率。</li>
<li>问题： 分类问题（Classification）和回归问题（Regression）<ul>
<li>分类问题： 离散型（如预测乳腺癌良性、恶性还有预测明天下午5点会不会下雨），预测的离散输出值(0, 1)。</li>
<li>回归问题： 连续型（如预测房屋价格），预测结果为连续的输出值。</li>
</ul>
</li>
<li>案例：<ul>
<li>Given genetic (DNA) data from a person, predict the odds of him/her developing diabetes over the next 10 years.</li>
<li>Given 50 articles written by male authors, and 50 articles written by female authors, learn to predict the gender of a new manuscript’s author (when the identity of this author is unknown).</li>
</ul>
</li>
</ol>
<p>(2) 无监督学习(Unsupervised learning)</p>
<ol>
<li>概念： 与有监督学习相比，训练集没有人为标注的结果。</li>
<li>理解： 对输入的训练集没有进行标注，即不告诉你分类情况，让机器自己进行相应的分类，即无监督学习常见算法聚类。</li>
<li>案例： Google News， 基因序列分析，社会网络分析，市场切分等。</li>
<li>特别的例子： 鸡尾酒宴会。<ul>
<li>鸡尾酒问题算法： [W,s,v] = svd((repmat(sum(x.<em>x,1),size(x,1),1).</em>x)*x’);</li>
</ul>
</li>
</ol>
<p>(3) 半监督学习</p>
<p>介于监督学习与无监督学习之间。</p>
<p>(4) 强化学习(Reinforcement learning)</p>
<p>通过观察来学习如何做出动作，每个动作都会对环境有所影响，而环境的反馈又可以引导该学习算法。</p>
<p>(5) 其他</p>
<p>还有其他包括推荐系统，Transduction，Learning to learn等类型。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="机器学习简介">机器学习简介</h2>
<h3 id="一、定义">一、定义</h3>
<blockquote>
<p>Arthur Samuel (1959): Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed.<br>Tom Mitchell (1998) : Well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.</p>
</blockquote>
]]></summary>
    
      <category term="Machine Learning" scheme="http://beforeload.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://beforeload.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Summary of Distributed Computing Learning Resourses]]></title>
    <link href="http://beforeload.github.io/2013/07/11/summary-of-distribute-computing-learning-resourses/"/>
    <id>http://beforeload.github.io/2013/07/11/summary-of-distribute-computing-learning-resourses/</id>
    <published>2013-07-11T13:01:59.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="分布式计算相关资源总结">分布式计算相关资源总结</h2>
<h3 id="论文">论文</h3>
<p>首先是论文，强烈建议看英文原版，那些翻译的还是敬而远之吧！</p>
<blockquote>
<p>Google出品，必属精品！</p>
</blockquote>
<a id="more"></a>

<h4 id="四大经典论文(必看)">四大经典论文(必看)</h4>
<ol>
<li><p>The Anatomy of a Large-Scale Hypertextual Web Search Engine</p>
<p>分布式计算的奠基制作，介绍了Google搜索引擎的原型，讲解了一个基于超文本的大型系统建立过程。</p>
</li>
<li><p>The Google File System</p>
<p>GFS这篇论文已然成为分布式文件系统相关技术的一种标准。对于分布式应用的接口，分布式系统设计，<br>数据的存储以及分布式系统监控和管理相关的技术实现具有指导意义。</p>
</li>
<li><p>MapReduce: Simplified Data Processing on Large Clusters</p>
<p>MapReduce的奠基之作，就凭它提出了MapReduce编程模式，就必须要读这篇论文。通过它，可以初窥云计算的世界。<br>Google在四位数以上的个节点上运行MapReduce，并且还在持续扩展中。</p>
</li>
<li><p>BigTable: A Distributed Storage System for Structured Data.</p>
<p>这篇论文主要实现了分布式存储数据的结构化，Google Earth和网页索引都是基于BigTable实现。论文很清晰的讲解了BigTable的设计实现思路和方法。</p>
</li>
</ol>
<h4 id="三篇补充论文(推荐看)">三篇补充论文(推荐看)</h4>
<ol>
<li><p>Dynamo</p>
<p>Google原始之作！</p>
</li>
<li><p><a href="http://www.sosp2007.org/papers/sosp064-aguilera.pdf" target="_blank" rel="external">Sinfonia: A New Paradigm for Building Scalable Distributed Systems</a></p>
<p>阐述构建分布式文件系统的范式方法。淘宝构建TFS，OceanBase和Tair等系统的时候充分参考了这篇论文！</p>
</li>
<li><p><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/zh-CN//archive/chubby-osdi06.pdf" target="_blank" rel="external">The Chubby lock service for loosely-coupled distributed systems</a></p>
<p>Google的BigTable，MapReduce和Spanner服务都是在这个基础上构建的！分布式事务的基础，我正在看这篇论文。</p>
</li>
<li><p><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/es//archive/spanner-osdi2012.pdf" target="_blank" rel="external">Spanner: Google’s Globally-Distributed Database</a></p>
</li>
</ol>
<p>第一个全球意义上的分布式数据库，推荐它的其中一个原因是，我完全看不懂！！！</p>
<h4 id="其他论文">其他论文</h4>
<p>这里还有一份别人总结的<a href="http://duanple.blog.163.com/blog/static/709717672011330101333271/" target="_blank" rel="external">分布式系统领域经典论文翻译集</a>。</p>
<p><strong><em>论文来源和下载：</em></strong></p>
<p>大多数论文来源于OSDI上。可以直接去会议网站上下载。直接google scholar一下，也可以下载。</p>
<h3 id="书籍">书籍</h3>
<h4 id="分布式计算">分布式计算</h4>
<ol>
<li><a href="http://book.douban.com/subject/3108801/" target="_blank" rel="external">分布式系统原理与范型</a></li>
<li><a href="http://book.douban.com/subject/2698938/" target="_blank" rel="external">分布式系统概念与设计</a></li>
</ol>
<h4 id="Hadoop">Hadoop</h4>
<ol>
<li><p>《Hadoop in action》、 《Hadoop实战》</p>
<p>我看的第一本分布式计算的书，里面的内容有点老。入门的书籍，所以推荐的时候难免掺杂了感情分。</p>
</li>
<li><p>《Oreilly.Hadoop.The.Definitive.Guide.2nd.Edition 》</p>
<p>中文版本就不推荐了，直接看英文版的吧！</p>
</li>
<li><p>《Hadoop权威指南》</p>
</li>
</ol>
<p>这本书同样适合初学者，书里面有基础的实例实现。属于分布式计算方面少数可以看的中文书。<br>翻译的比较成功的两本书！当然看原版更好！</p>
<h4 id="其他书籍">其他书籍</h4>
<ol>
<li>《推荐系统实践》</li>
<li>《集体智慧编程》</li>
</ol>
<h3 id="其他Hadoop教程">其他Hadoop教程</h3>
<ol>
<li>《深入浅出Hadoop实战开发30讲》</li>
<li>《Hadoop应用开发实战 28讲》</li>
<li>《Cloudera Hadoop 4系列实战课程40讲》</li>
</ol>
<h3 id="总结">总结</h3>
<p>学习分布式计算，建议先去研究一下分布式计算的理论知识，然后学习一种框架，以Hadoop为例，从入门到精通！</p>
<ol>
<li><p>环境搭建</p>
<p><a href="http://beforeload.github.io/2013/06/29/building-distributed-systems-development-environment/" target="_blank" rel="external">基于Hadoop的分布式系统开发环境在Ubuntu 13.04中的搭建</a></p>
</li>
<li><p>MapReduce</p>
<p><a href="http://beforeload.github.io/2013/04/13/analyze-mapreduce/" target="_blank" rel="external">MapReduce</a></p>
</li>
<li><p>Hadoop的一点应用</p>
<ul>
<li><a href="http://beforeload.github.io/2013/04/06/hdfs-java-api/" target="_blank" rel="external">理解 Hadoop 的 Java API</a></li>
<li><a href="http://beforeload.github.io/2013/04/18/invertedindex-in-hadoop/" target="_blank" rel="external">倒排索引</a></li>
</ul>
</li>
</ol>
<p>看论文和书籍只是一部分，懂理论才算刚刚入门！要努力做到能应用还要争取有创新！</p>
<p>另外, Hadoop不代表分布式，还有很多类似于Hadoop且比Hadoop更具有优势的框架，如Spark就更适合实验室内的研究的小规模分布式系统，Storm更适用于实时数据流。</p>
<p>附： </p>
<ol>
<li><a href="http://aoyouzi.iteye.com/blog/1845235" target="_blank" rel="external">推荐系统公共资源汇总</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<h2 id="分布式计算相关资源总结">分布式计算相关资源总结</h2>
<h3 id="论文">论文</h3>
<p>首先是论文，强烈建议看英文原版，那些翻译的还是敬而远之吧！</p>
<blockquote>
<p>Google出品，必属精品！</p>
</blockquote>
]]></summary>
    
      <category term="Distributed Computing" scheme="http://beforeload.github.io/tags/Distributed-Computing/"/>
    
      <category term="Hadoop" scheme="http://beforeload.github.io/tags/Hadoop/"/>
    
      <category term="Linux" scheme="http://beforeload.github.io/tags/Linux/"/>
    
      <category term="Distributed Computing" scheme="http://beforeload.github.io/categories/Distributed-Computing/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Building Distributed Systems Development Environment]]></title>
    <link href="http://beforeload.github.io/2013/06/29/building-distributed-systems-development-environment/"/>
    <id>http://beforeload.github.io/2013/06/29/building-distributed-systems-development-environment/</id>
    <published>2013-06-28T17:13:47.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基于Hadoop的分布式系统开发环境在Ubuntu_13-04中的搭建">基于Hadoop的分布式系统开发环境在Ubuntu 13.04中的搭建</h2>
<p>由于实验学习以及开发测试的需求，需要安装集群和伪分布式开发环境。</p>
<p>分为以下安装过程：</p>
<ol>
<li>安装jdk</li>
<li>安装eclipse</li>
<li>安装hadoop</li>
</ol>
<a id="more"></a>

<h3 id="安装jdk">安装jdk</h3>
<p><strong>(1) 下载JDK</strong></p>
<p>Ubuntu上下载最好不要使用FTP下载，不然会出现例如下面的问题。</p>
<pre><code>gzip: stdin: invalid compressed data--format violatedtar: Unexpected EOF <span class="keyword">in</span> archivetar: Unexpected EOF <span class="keyword">in</span> archivetar: <span class="keyword">Error</span> <span class="keyword">is</span> <span class="keyword">not</span> recoverable: exiting <span class="built_in">now</span>
</code></pre><p>从<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank" rel="external">官网</a>上根据自己的系统下载相应的JDK。</p>
<pre><code><span class="built_in">sudo</span> mkdir /usr/java
tar zxvf jdk-<span class="number">7</span>u25-linux-x64.tar.gz
<span class="built_in">sudo</span> mv jdk-<span class="number">7</span>u25-linux-x64.tar.gz /usr/java/
</code></pre><p><strong>(2) 然后修改配置文件</strong></p>
<pre><code>sudo <span class="keyword">vi</span> /etc/<span class="keyword">profile</span>
</code></pre><p>按G可以直接到文件尾端，填写下面内容:</p>
<pre><code><span class="keyword">export</span> JAVA_HOME=/usr/java/jdk1.<span class="number">7.0</span>_25
<span class="keyword">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre
<span class="keyword">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar
<span class="keyword">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin
</code></pre><p>保存退出。</p>
<p><strong>(3) 检测是否成功</strong> </p>
<pre><code><span class="keyword">source</span> /etc/<span class="keyword">profile</span>
java -<span class="keyword">version</span>
</code></pre><p>如果显示下面结果，表示安装成功。</p>
<pre><code>java <span class="keyword">version</span> <span class="string">"1.7.0_25"</span>
Java(TM) SE Runtime Environment (build <span class="number">1.7</span>.<span class="number">0</span>_25-b15)
Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (build <span class="number">23.25</span>-b01, mixed <span class="built_in">mode</span>)
</code></pre><h3 id="安装eclipse">安装eclipse</h3>
<p><strong>(1) 下载eclipse<em>*</em>.tar.gz</strong></p>
<pre><code>tar zxvf eclipse-standard-kepler-R-linux-gtk-x86_64.tar.gz
mv eclipse <span class="regexp">/usr/</span>local
<span class="regexp">/usr/</span>local<span class="regexp">/eclipse/</span>eclipse    #启动eclipse
</code></pre><p><strong>(2) 通过修改快捷键，可以迅速启动eclipse</strong></p>
<pre><code><span class="input"><span class="prompt">System Settings -&gt;</span> <span class="constant">Keyboard</span> -&gt; <span class="constant">Shortcuts</span> -&gt; <span class="constant">Custom</span> <span class="constant">Shortcuts</span></span>
</code></pre><p><strong><em>在弹窗中输入：</em></strong></p>
<pre><code><span class="attribute">Name</span>: <span class="string">eclipse</span>
<span class="attribute">Command</span>: <span class="string">/usr/local/eclipse/eclipse</span>
</code></pre><p>Apply退出后，<code>Ctrl+Alt+E</code>，添加快捷键。以后只需要通过<code>Ctrl+Alt+E</code>，即可启动Eclipse。</p>
<h4 id="ssh_无密码登录">ssh 无密码登录</h4>
<p><strong>(1) 安装SSH</strong></p>
<pre><code>sudo apt-get <span class="operator"><span class="keyword">install</span> openssh-<span class="keyword">server</span></span>
</code></pre><p>如果你想让别的机器访问自己的电脑，只需要把公钥告诉别人，其他机器通过public key加密后，把数据传到自己的机器上，自己的机器用私钥进行解密。</p>
<p><strong>(2) 生成密钥的步骤也很简单：</strong></p>
<pre><code>ssh-keygen -t rsa -<span class="keyword">C</span> <span class="string">"your_email@example.com"</span>
</code></pre><p>详细步骤请参见<a href="//help.github.com/articles/generating-ssh-keys">Generating SSH Keys</a></p>
<pre><code><span class="keyword">cp</span> id_rsa.pub authorized_keys
</code></pre><p><strong>(3) 测试一下，是否可以无密码连接</strong></p>
<pre><code><span class="title">ssh</span> localhost
</code></pre><p>集群配置的时候可以直接从namenode中，把新增的电脑上的public key发到namenode中，添加到它的authorized_keys中，<br>然后使用<code>scp</code>命令拷贝到新增机器上即可。</p>
<h4 id="安装Hadoop">安装Hadoop</h4>
<p><strong>(1) 下载解压hadoop</strong></p>
<pre><code><span class="title">tar</span> zxvf hadoop-<span class="number">0</span>.<span class="number">20</span>.<span class="number">2</span>.tar.gz    <span class="comment">#解压</span>
</code></pre><p><strong>(2) 配置四个文件</strong></p>
<p>1) ~/hadoop-0.20.2/conf/hadoop-env.sh</p>
<pre><code><span class="keyword">export</span> JAVA_HOME=<span class="regexp">/usr/</span>java/jdk1<span class="number">.7</span><span class="number">.0</span>_25
</code></pre><p>2) ~/hadoop-0.20.2/conf/core-site.xml</p>
<pre><code><span class="tag">&lt;<span class="title">configuration</span>&gt;</span> 
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</code></pre><p>3) ~/hadoop-0.20.2/conf/hdfs-site.xml</p>
<pre><code><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>1<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</code></pre><p>4) ~/hadoop-0.20.2/conf/mapred-site.xml</p>
<pre><code><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapred.job.tracker<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>localhost:9001<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</code></pre><p><strong>(3) 修改～/.bashrc</strong></p>
<pre><code><span class="built_in">echo</span> <span class="string">'export HADOOP_HOME=/home/beforeload/hadoop-0.20.2'</span> &gt;&gt; ~/.bashrc
<span class="built_in">echo</span> <span class="string">'export PATH=$PATH:$HADOOP_HOME/bin'</span> &gt;&gt; ~/.bashrc
<span class="built_in">source</span> ~/.bashrc
</code></pre><p>现在在任何目录下，都可以输入hadoop命令了。</p>
<p><strong>(4) 格式化HDFS并启动hadoop</strong></p>
<pre><code>hadoop namenode -format
start-<span class="literal">all</span>.sh
jps   <span class="comment">#查看运行的进程</span>
</code></pre><p><strong>(5) 浏览NameNode 和 JobTracker</strong></p>
<ol>
<li>NameNode <a href="http://localhost:50070/dfshealth.jsp" target="_blank" rel="external">http://localhost:50070/dfshealth.jsp</a></li>
<li>JobTracker <a href="http://localhost:50030/jobtracker.jsp" target="_blank" rel="external">http://localhost:50030/jobtracker.jsp</a></li>
</ol>
<p><strong>(6) 重要参数</strong></p>
<pre><code><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span>     
<span class="built_in">echo</span> <span class="variable">$HADOOP_HOME</span>
</code></pre>]]></content>
    <summary type="html"><![CDATA[<h2 id="基于Hadoop的分布式系统开发环境在Ubuntu_13-04中的搭建">基于Hadoop的分布式系统开发环境在Ubuntu 13.04中的搭建</h2>
<p>由于实验学习以及开发测试的需求，需要安装集群和伪分布式开发环境。</p>
<p>分为以下安装过程：</p>
<ol>
<li>安装jdk</li>
<li>安装eclipse</li>
<li>安装hadoop</li>
</ol>
]]></summary>
    
      <category term="Ubuntu" scheme="http://beforeload.github.io/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://beforeload.github.io/tags/Linux/"/>
    
      <category term="Hadoop" scheme="http://beforeload.github.io/tags/Hadoop/"/>
    
      <category term="Linux" scheme="http://beforeload.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Common Software Installation and Configuration on Ubuntu 13.04]]></title>
    <link href="http://beforeload.github.io/2013/06/22/my-software-installation-and-configuration-on-ubuntu-1304/"/>
    <id>http://beforeload.github.io/2013/06/22/my-software-installation-and-configuration-on-ubuntu-1304/</id>
    <published>2013-06-22T13:23:50.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Ubuntu_13-04上常用软件的安装配置">在Ubuntu 13.04上常用软件的安装配置</h1>
<p>安装完Ubuntu 13.04 后，我的一些软件安装和配置过程。</p>
<ol>
<li><a href="#-5b89-88c5-zsh-548c-oh-my-zsh">安装zsh和oh-my-zsh</a></li>
<li><a href="#Ubuntu_-7ec8-7aef-900f-660e-5316-">终端透明化</a></li>
<li><a href="#-5b89-88c5-_chrome">安装chrome</a></li>
<li><a href="#-5b89-88c5-git">安装git</a></li>
<li><a href="#-5b89-88c5-VLC-89c6-9891-64ad-653e-5668-">安装VLC播放器</a></li>
<li><a href="#-5b89-88c5-sougou_-2b-_fcitx">安装fcitx + 搜狗拼音</a></li>
<li><a href="#-5b89-88c5-914d-7f6e-VIM">安装vim</a></li>
<li><a href="#-5b89-88c5-Node-js">安装Node.js</a></li>
<li><a href="#-5b89-88c5-9510-6377-6821-56ed-7f51-5ba2-6237-7aef-">安装锐捷校园网客户端</a></li>
<li><a href="#-5b89-88c5-914d-7f6e-JDK">安装配置jdk</a></li>
</ol>
<a id="more"></a>

<h2 id="安装zsh和oh-my-zsh">安装zsh和oh-my-zsh</h2>
<p><strong><em>安装 curl:</em></strong></p>
<pre><code><span class="built_in">sudo</span> apt-get install curl
</code></pre><p>然后:</p>
<pre><code><span class="built_in">sudo</span> apt-get install zsh
</code></pre><p><strong><em>可以通过curl方式安装：</em></strong></p>
<pre><code>curl -L http<span class="variable">s:</span>//github.<span class="keyword">com</span>/robbyrussell/oh-my-zsh/raw/master/tools/install.<span class="keyword">sh</span> | <span class="keyword">sh</span>
</code></pre><p><strong><em>也可以通过wget：</em></strong></p>
<pre><code>wget --<span class="keyword">no</span>-check-certificate http<span class="variable">s:</span>//github.<span class="keyword">com</span>/robbyrussell/oh-my-zsh/raw/master/tools/install.<span class="keyword">sh</span> -O - | <span class="keyword">sh</span>
</code></pre><p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">参考文档</a></p>
<h2 id="Ubuntu_终端透明化">Ubuntu 终端透明化</h2>
<p>Ctrl+Alt+T 打开终端，菜单 </p>
<pre><code>Edit-&gt;Profile Preference-&gt;Background-&gt;Transparent background
</code></pre><h2 id="安装_chrome">安装 chrome</h2>
<p><strong><em>安装依赖:</em></strong></p>
<pre><code><span class="built_in">sudo</span> apt-get install (依赖包)
</code></pre><p>然后从google chrome官方网站上下载安装</p>
<pre><code><span class="title">sudo</span> dpkg -i google-chrome-stable_<span class="regexp">*.deb</span>
</code></pre><p>终端输入<code>google-chrome</code>即可启动。</p>
<h2 id="安装git">安装git</h2>
<pre><code><span class="built_in">sudo</span> apt-get install git
</code></pre><p><strong><em>相关配置:</em></strong></p>
<pre><code>git config --<span class="keyword">global</span> user.name beforeload
git config --<span class="keyword">global</span> user.email fe.daniel91<span class="variable">@gmail</span>.com
git config --<span class="keyword">global</span> <span class="keyword">color</span>.diff auto
git config --<span class="keyword">global</span> <span class="keyword">color</span>.branch auto
git config --<span class="keyword">global</span> <span class="keyword">color</span>.ui true
git config --<span class="keyword">global</span> <span class="keyword">color</span>.interactive auto
git config --<span class="keyword">global</span> <span class="keyword">color</span>.status auto
git config --<span class="keyword">global</span> push.<span class="keyword">default</span> current
git config --<span class="keyword">global</span> core.<span class="keyword">editor</span> vim
git config --<span class="keyword">global</span> core.autocrlf off
git config --<span class="keyword">global</span> merge.tool vimdiff
</code></pre><h3 id="查看配置">查看配置</h3>
<p><strong><em>查看所有配置:</em></strong></p>
<pre><code>git config --<span class="keyword">list</span>
</code></pre><p><strong><em>查看某个配置:</em></strong></p>
<pre><code>git config <span class="literal">user</span>.name
</code></pre><p>或者 </p>
<pre><code><span class="keyword">cat</span> ~/.gitconfig
</code></pre><h2 id="安装VLC视频播放器">安装VLC视频播放器</h2>
<pre><code><span class="built_in">sudo</span> apt-get install vlc
</code></pre><p>终端输入<code>vlc</code>启动，在菜单栏</p>
<pre><code><span class="input"><span class="prompt">Tools-&gt;</span> <span class="constant">Preference</span> -&gt; <span class="constant">Subtitles</span> &amp; <span class="constant">OSD</span> 修改<span class="constant">Default</span> encoding为<span class="constant">Universal</span>(<span class="constant">UTF</span>-<span class="number">8</span>),或者<span class="constant">GBK</span></span>
</code></pre><p>还可以设置相关中文字体（中文可选）。</p>
<p>然后在右上角:</p>
<pre><code><span class="input"><span class="prompt">System Settings -&gt;</span> <span class="constant">Details</span> -&gt; <span class="constant">Default</span> <span class="constant">Applications</span> -&gt; <span class="constant">Video</span>选择<span class="constant">VLC</span> media player</span>
</code></pre><p>这样打开相关视频文件，可以直接使用VLC播放。</p>
<h2 id="安装sougou_+_fcitx">安装sougou + fcitx</h2>
<pre><code>sudo <span class="built_in">add</span>-apt-repository <span class="keyword">pp</span><span class="variable">a:fcitx</span>-team/nightly
sudo apt-<span class="built_in">get</span> <span class="keyword">update</span>
sudo apt-<span class="built_in">get</span> install fcitx-sogoupinyin
</code></pre><p>然后在<code>System Settings -&gt; Language Support -&gt; Keyboard input method system</code> 中选择 fcitx。</p>
<p><strong><em>[可选]安装皮肤：</em></strong></p>
<p>下载<a href="http://pan.baidu.com/share/link?shareid=591450&amp;uk=4060302862" target="_blank" rel="external">fcitx-sougou-skin</a></p>
<pre><code><span class="built_in">sudo</span> dpkg -i fcitx-skin-sogou_0.<span class="number">0.2</span>_all.deb
</code></pre><p>在fcitx外观中选择sougou即可。</p>
<p>最后注销，重新登录，输入法生效。</p>
<h2 id="安装配置VIM">安装配置VIM</h2>
<pre><code>sudo apt-<span class="built_in">get</span> install <span class="keyword">vim</span>
</code></pre><p><strong><em>配置：</em></strong></p>
<p>安装vundle</p>
<pre><code>git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/gmarik/vundle.git ~/.<span class="keyword">vim</span>/bundle/vundle
</code></pre><p>用<a href="https://github.com/beforeload/myconf/blob/master/.vimrc" target="_blank" rel="external">我的.vimrc配置文件</a><br>覆盖<code>~/.vimrc</code>文件即可</p>
<p>在vim中执行<code>:BundleInstall</code>,自动安装vim插件。</p>
<p>Powerline中下面的箭头可能存在字体问题，解决的办法是给字体打补丁。</p>
<h2 id="安装Node-js">安装Node.js</h2>
<p>安装依赖</p>
<pre><code><span class="built_in">sudo</span> apt-get install build-essential libssl-dev
</code></pre><p>编译安装</p>
<pre><code><span class="built_in">mkdir</span> node &amp;&amp; <span class="keyword">cd</span> node
git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/joyent/node.git
./configure
<span class="keyword">make</span> 
<span class="keyword">make</span> install
</code></pre><h2 id="安装锐捷校园网客户端">安装锐捷校园网客户端</h2>
<p>下载<a href="http://ncs.hust.edu.cn/download/soft/Linux\ SU\ V1.01版.rar" target="_blank" rel="external">Linux SU V 1.01</a></p>
<p>安装unrar</p>
<pre><code>sudo apt-get install unrar

unrar <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>.rar
tar -zxvf <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>.tar.gz

cd rjsupplicant/
</code></pre><p>查看设置</p>
<pre><code><span class="built_in">sudo</span> ./rjsupplicant.sh -h
</code></pre><p>设置好后启动</p>
<pre><code><span class="built_in">sudo</span> ./rjsupplicant.sh
</code></pre><h2 id="安装配置JDK">安装配置JDK</h2>
<p>相关安装步骤已经在另外<a href="//beforeload.github.io/2013/06/29/building-distributed-systems-development-environment/">一篇博文</a>中做出更新。</p>
]]></content>
    <summary type="html"><![CDATA[<h1 id="在Ubuntu_13-04上常用软件的安装配置">在Ubuntu 13.04上常用软件的安装配置</h1>
<p>安装完Ubuntu 13.04 后，我的一些软件安装和配置过程。</p>
<ol>
<li><a href="#-5b89-88c5-zsh-548c-oh-my-zsh">安装zsh和oh-my-zsh</a></li>
<li><a href="#Ubuntu_-7ec8-7aef-900f-660e-5316-">终端透明化</a></li>
<li><a href="#-5b89-88c5-_chrome">安装chrome</a></li>
<li><a href="#-5b89-88c5-git">安装git</a></li>
<li><a href="#-5b89-88c5-VLC-89c6-9891-64ad-653e-5668-">安装VLC播放器</a></li>
<li><a href="#-5b89-88c5-sougou_-2b-_fcitx">安装fcitx + 搜狗拼音</a></li>
<li><a href="#-5b89-88c5-914d-7f6e-VIM">安装vim</a></li>
<li><a href="#-5b89-88c5-Node-js">安装Node.js</a></li>
<li><a href="#-5b89-88c5-9510-6377-6821-56ed-7f51-5ba2-6237-7aef-">安装锐捷校园网客户端</a></li>
<li><a href="#-5b89-88c5-914d-7f6e-JDK">安装配置jdk</a></li>
</ol>
]]></summary>
    
      <category term="Ubuntu" scheme="http://beforeload.github.io/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://beforeload.github.io/tags/Linux/"/>
    
      <category term="Linux" scheme="http://beforeload.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Priority Queue]]></title>
    <link href="http://beforeload.github.io/2013/05/30/priority-queue/"/>
    <id>http://beforeload.github.io/2013/05/30/priority-queue/</id>
    <published>2013-05-29T16:40:13.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>以6.5-1的数据作为输入 实现heapsort, 以及图解排序过程 </li>
<li>实现6.5-3所描述的最小优先级队列接口, 分析各接口所需的时间复杂度 </li>
<li>练习6.5-8 </li>
</ol>
<a id="more"></a>

<p>6.5-1 HEAP-EXTRACT-MAX</p>
<pre><code><span class="keyword">if</span> head-size[A] &lt; <span class="number">1</span>
    <span class="keyword">then</span> error
<span class="built_in">max</span> &lt;<span class="comment">-- A[1]</span>
A[<span class="number">1</span>] &lt;<span class="comment">-- heap-size[A] - 1</span>
MAX-HEAPIFY(A, <span class="number">1</span>)
<span class="constant">return</span> <span class="built_in">max</span>
</code></pre><img src="http://i.minus.com/imDBy99LrOzWP.jpg">

<p>6.5-3 HEAP-MINIUM(A)</p>
<p>伪代码书上已经有了</p>
<pre><code>HEAP-MINIMUM(<span class="literal">A</span>)
    <span class="keyword">return</span> <span class="literal">A</span>[<span class="number">1</span>]
</code></pre><p>利用HEAP-EXTRACT-MAX(A)容易写出HEAP-EXTRACT-MIN(A)</p>
<h4 id="HEAP-EXTRACT-MIN(A)">HEAP-EXTRACT-MIN(A)</h4>
<pre><code><span class="keyword">if</span> heap-size[<span class="literal">A</span>] &lt; <span class="number">1</span>
    then error 
max &lt;- <span class="literal">A</span>[<span class="number">1</span>]
<span class="literal">A</span>[<span class="number">1</span>] &lt;- <span class="literal">A</span>[heap-size[<span class="literal">A</span>]] - <span class="number">1</span>
heap-size[<span class="literal">A</span>] &lt;- heap-size[<span class="literal">A</span>] - <span class="number">1</span>
MIN-HEAPIFY(<span class="literal">A</span>, <span class="number">1</span>)
<span class="keyword">return</span> max
</code></pre><p>同样，由HEAD-INCREASE-KEY很容易就写出HEAD-DECREASE-KEY过程的伪代码：</p>
<h4 id="HEAD-DECREASE-KEY">HEAD-DECREASE-KEY</h4>
<pre><code><span class="keyword">if</span> key &gt; <span class="literal">A</span>[i]
    then error
<span class="literal">A</span>[i] &lt;- key
<span class="keyword">while</span> i &gt; <span class="number">1</span> <span class="literal">and</span> <span class="literal">A</span>[PARENT(i)] &gt; <span class="literal">A</span>[i]
    do exchange <span class="literal">A</span>[i] &lt;-&gt; <span class="literal">A</span>[PARENT(i)]
            i &lt;- PARENT(i)
</code></pre><p>同样，由MAX-HEAP-INSERT容易写出MIN-HEAP-INSERT</p>
<h4 id="MIN-HEAP-INSERT">MIN-HEAP-INSERT</h4>
<pre><code>heap-size[<span class="literal">A</span>] &lt;- heap-size[<span class="literal">A</span>] + <span class="number">1</span>
<span class="literal">A</span>[heap-size[<span class="literal">A</span>]] &lt;- 无穷
HEAP-INCREASE-KEY(<span class="literal">A</span>, heap-size[<span class="literal">A</span>], key)
</code></pre><p>6.5-8</p>
<p>每一个链表作为一个节点，链表的第一个元素作为key，然后组成一个堆，这个堆的大小为K(k个链表，k个节点)。</p>
<p>链表合并过程思路如下：</p>
<ol>
<li>通过堆的根节点，获得其链表的第一个元素</li>
<li>以获取的元素作为目标链表的尾端</li>
<li>因为根的第一个元素的key发生改变，对其进行MIN-HEAPFIY操作，递归进行下去。</li>
</ol>
<p>显然，在每个堆中取一个key组成的堆是实现此过程的一个最小堆。</p>
<p>具体的实现代码实在没有时间写了。</p>
]]></content>
    <summary type="html"><![CDATA[<ol>
<li>以6.5-1的数据作为输入 实现heapsort, 以及图解排序过程 </li>
<li>实现6.5-3所描述的最小优先级队列接口, 分析各接口所需的时间复杂度 </li>
<li>练习6.5-8 </li>
</ol>
]]></summary>
    
      <category term="Algorithm" scheme="http://beforeload.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://beforeload.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Fix Some Ubuntu Problems]]></title>
    <link href="http://beforeload.github.io/2013/05/20/fix-some-problems/"/>
    <id>http://beforeload.github.io/2013/05/20/fix-some-problems/</id>
    <published>2013-05-20T14:10:58.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="解决_Ubuntu_13-04的视频音频相关问题">解决 Ubuntu 13.04的视频音频相关问题</h2>
<ol>
<li>Fix ASUS Webcam Problem:vertically flip my webcam’s image</li>
</ol>
<p><strong><em>问题描述</em></strong>：华硕电脑摄像头视频图像倒立</p>
<p>解决方法： 在google上搜索了一下 ubuntu camera invert找到几篇解决的博文，步骤如下：</p>
<a id="more"></a>

<p>(1) Install</p>
<pre><code>$echo -e "\n# libv4l PPA\ndeb http://ppa.launchpad.net/libv4l/ppa/ubuntu <span class="smartquote">`lsb_release -c | awk '</span>{print $2}<span class="emphasis">'` main" | sudo tee -a /etc/apt/sources.list

</span>$sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com C3FFB4AA

$sudo apt-get update

$sudo apt-get install libv4l-0
</code></pre><p>(2) Start application</p>
<pre><code><span class="variable">$export</span> <span class="constant">LIBV4LCONTROL_FLAGS</span>=<span class="number">3</span> &amp;&amp; cheese
<span class="variable">$export</span> <span class="constant">LIBV4LCONTROL_FLAGS</span>=<span class="number">3</span> &amp;&amp; <span class="constant">LD_PRELOAD</span>=<span class="regexp">/usr/lib</span><span class="regexp">/i386-linux-gnu/libv</span>4l/v4l1compat.so skype
</code></pre><p>为了以后不需要输入这么多，建立一个bash<br>Step 1:</p>
<pre><code>$sudo gedit <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>skype
</code></pre><p>填写下面内容</p>
<pre><code>LD_PRELOAD=<span class="regexp">/usr/</span>lib<span class="regexp">/i386-linux-gnu/</span>libv4l<span class="regexp">/v4l1compat.so /</span>usr<span class="regexp">/bin/</span>skype
</code></pre><p>Step 2:</p>
<pre><code>sudo chmod a+x <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>skype
</code></pre><p><strong><em>注意</em></strong>：</p>
<ol>
<li><p>v4l1compat.so的位置在Ubuntu 13.04上可能和之前的版本不同，使用locate指令可以先确定一下位置。</p>
<p> $ locate v4l1compat.so<br> /usr/lib/i386-linux-gnu/libv4l/v4l1compat.so</p>
</li>
</ol>
<p><strong><em>参考</em></strong>：</p>
<p>(1) <a href="http://www.paullabis.com/2010/08/fix-upside-down-or-inverted-webcam-on.html" target="_blank" rel="external">Fix upside-down or inverted webcam on Ubuntu linux</a></p>
<p>(2)<a href="http://community.linuxmint.com/tutorial/view/219" target="_blank" rel="external">How to make Webcam compatible with Skype.</a></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="解决_Ubuntu_13-04的视频音频相关问题">解决 Ubuntu 13.04的视频音频相关问题</h2>
<ol>
<li>Fix ASUS Webcam Problem:vertically flip my webcam’s image</li>
</ol>
<p><strong><em>问题描述</em></strong>：华硕电脑摄像头视频图像倒立</p>
<p>解决方法： 在google上搜索了一下 ubuntu camera invert找到几篇解决的博文，步骤如下：</p>
]]></summary>
    
      <category term="Ubuntu" scheme="http://beforeload.github.io/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://beforeload.github.io/tags/Linux/"/>
    
      <category term="Linux" scheme="http://beforeload.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[inversion monge quicksort]]></title>
    <link href="http://beforeload.github.io/2013/05/17/inversion-monge-quicksort/"/>
    <id>http://beforeload.github.io/2013/05/17/inversion-monge-quicksort/</id>
    <published>2013-05-17T14:44:25.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="逆序对，Monge矩阵，快排优化——三数取中划分分析">逆序对，Monge矩阵，快排优化——三数取中划分分析</h2>
<h3 id="题目">题目</h3>
<ol>
<li>第二章思考题2-4(逆序对)</li>
<li>第四章思考题4-7(Monge矩阵)</li>
<li>第七章思考题7-5(快排的三数取中划分分析)</li>
</ol>
<a id="more"></a>

<h3 id="2-4_逆序对">2-4 逆序对</h3>
<p>a)</p>
<script src="https://gist.github.com/5599553.js?file=inversion.c"></script>

<p>结果: </p>
<p>(2,3)<br>(2,8)<br>(2,6)<br>(3,8)<br>(3,6)</p>
<p>b)</p>
<p>从1到n按倒序排列的数组含有最多的逆序对，<br>个数为(n-1)+(n-2)+…+1 = (n-1 + 1) <em> (n-1)/2 = n </em> (n-1)/2</p>
<p>c)</p>
<p>插入排序的运行时间与输入数组中逆序对的数量之间有怎样的关系?</p>
<p>当数组从小到大排序，插入排序算法复杂度最优为O(n),此时逆序对为0;</p>
<p>当数组从大到小排序，插入排序算法复杂度最坏情况，此时逆序对最多为n * (n-1)/2;</p>
<p>插入排序的过程如下：</p>
<figure class="highlight C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> insert_sort(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line">	<span class="keyword">int</span> i, j, key;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; i++) {</div><div class="line">		key = arr[i];</div><div class="line">		j = i;</div><div class="line">		<span class="keyword">while</span> (j &gt; <span class="number">0</span> && arr[j - <span class="number">1</span>] &gt; key) {</div><div class="line">			arr[j] = arr[j - <span class="number">1</span>];</div><div class="line">			j--;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) {</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>每多一个逆序对存在，就需要多一次比较，运行时间增加。插入排序每次比较后交换元素都是减少一对逆序对，循环本身是对所有的逆序对排序的过程。   </p>
<p>d)<br>O(nlg(n))修改合并排序，确定n个元素的任意排列中逆序对的数目。</p>
<script src="https://gist.github.com/5599593.js?file=inversion_d.c"></script>


<h3 id="Monge矩阵">Monge矩阵</h3>
<p>a)证明：当且仅当矩阵中所有2×2的矩阵都为Monge矩阵时，这个矩阵才为Monge矩阵。</p>
<p>先对行使用归纳法：假设i,k行j，l列矩阵为Monge矩阵，证明i,k+1行，j,l列矩阵为Monge矩阵即可</p>
<p>(1)已知i,k行j,l列为Monge矩阵即A[i,j]+A[k,l] &lt;= A[i,l] + A[k,j]<br>(2)假设A[k,j] + A[k+1,l] &lt;= A[k+1,j] + A[k,l]<br>(3)只需要证明i,k+1行j,l列的矩阵为Monge矩阵，<br>由(1),(2)得A[i,j] + A[k+1,l] &lt;= A[k,j] + A[k+1,l]                </p>
<p>对列用归纳法也是相同步骤，</p>
<p>已知A[i, j]+A[k, n] ≤ A[i, n]+A[k,j]<br>假设<br>A[i, n]+A[k,n+1] ≤ A[i, n+1]+A[k,n]<br>所以A[i, j]+A[k, n+1] ≤ A[i, n+1]+A[k, j]成立。                </p>
<p>行和列都满足归纳法，当<code>A[i,j]+A[i+1,j+1] &lt;= A[i,j+1] + A[i+1,j]</code>时，整个矩阵为Monge矩阵。               </p>
<p><strong>“仅当”</strong>这个条件用反正法可证。           </p>
<p>b) 利用a)的结论：<code>A[i,j] + A[i+1,j+1] &lt;= A[i,j+1]+A[i+1,j]</code>              </p>
<p>很容易得到矩阵第二行第三列到第三行第四列的2×2矩阵不满足条件;<br>所以只需要将第二行第三列的16和第三行第三列的22交换即可。             </p>
<p>c)<br>假设Monge矩阵中存在第x行和第x+1行，<code>f(x) &gt; f(x+1)  (1 &lt;= x &lt; m)</code>               </p>
<p>已知<code>A[x,f(x+1)] + A[x+1, f(x)] &lt;= A[x,f(x)] + A[x+1, f(x+1)]</code>                </p>
<p>又因为             </p>
<p>A[x,f(x)] &lt; A[x, f(x+1)]        (1)<br>A[x+1,f(x+1)] &lt;= A[x+1, f(x)]   (2)</p>
<p>(1) + (2) 得：                 </p>
<p>A[x,f(x+1)] + A[x+1, f(x)] &gt; A[x, f(x)] + A[x+1,f(x+1)]   (3)</p>
<p>根据a)结论，任意2×2矩阵都有</p>
<p>A[i,j] + A[i+1,j+1] &lt;= A[i,j+1]+A[i+1,j]      (4)</p>
<p>(3) 和 (4)矛盾，假设不成立。<br>由此可得：</p>
<p>f(1) &lt;= f(2) &lt;= … &lt;= f(m)            </p>
<p>d) 已知偶数行最左端最小值f(2), f(4), f(6), …<br>且f(2k) &lt;= f(2k+1) &lt;= f(2(k+1))</p>
<p>奇数行搜索一次，搜索范围为n列，偶数行重复计算两次</p>
<p>奇数行最左端最小值时间复杂度O(m/2+n)=O(m+n)<br>e)<br>由d)可得递归式：T(m) = T(m/2) + O(m+n)</p>
<p>递归运算结果：</p>
<p>T(m) = O(nlgm) + O(m+n)<br>     = O(nlgm + m + n)<br>     = O(nlgm + m)              </p>
<h3 id="快排中三数取中划分分析">快排中三数取中划分分析</h3>
<p><img src="//i.minus.com/i29Ufb20Oolkw.jpg" class="[inversion]"><br>答案用图片显示，<a href="//i.minus.com/i29Ufb20Oolkw.jpg">图片在这里</a> </p>
<p>参考文章</p>
<ol>
<li><a href="//blog.csdn.net/zhanglei8893/article/details/6266915">“三数取中“划分</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<h2 id="逆序对，Monge矩阵，快排优化——三数取中划分分析">逆序对，Monge矩阵，快排优化——三数取中划分分析</h2>
<h3 id="题目">题目</h3>
<ol>
<li>第二章思考题2-4(逆序对)</li>
<li>第四章思考题4-7(Monge矩阵)</li>
<li>第七章思考题7-5(快排的三数取中划分分析)</li>
</ol>
]]></summary>
    
      <category term="Algorithm" scheme="http://beforeload.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://beforeload.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Collaborative Markov Chain Model]]></title>
    <link href="http://beforeload.github.io/2013/04/22/collaborative-markov-chain-model/"/>
    <id>http://beforeload.github.io/2013/04/22/collaborative-markov-chain-model/</id>
    <published>2013-04-22T13:23:27.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="理论">理论</h2>
<h3 id="马尔可夫过程(Markov_Process)">马尔可夫过程(Markov Process)</h3>
<p>Markov过程是一个满足Markov性(无后效性)的随机过程。<br>具有马尔可夫性质的随机过程称为<strong>马尔可夫</strong>过程。[1]</p>
<p>最有名的Markov过程是Markov链，但还有其他的过程，如布朗运动，也是Markov过程。</p>
<a id="more"></a>

<h3 id="马尔可夫性质">马尔可夫性质</h3>
<p><strong>马尔可夫性质</strong>是概率论中的一个概念。当一个随即过程在给定状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是条件独立的，那么此随机过程具有<strong>马尔可夫性质</strong>。[2]</p>
<p>过程或（系统）在时刻t0所处的状态为已知的条件下，过程在时刻t&gt;t0所处状态的条件分布，与过程在时刻t0之前所处的状态无关的特性称为马尔可夫性或无后效性。[1]即：已知“现在”过程的情况下，“<em>将来</em>”过程的情况与“<em>过去</em>”的情况无关。</p>
<p>数学上，如果’X(t),t&gt;0’为一个随机过程，则马尔可夫性质就是指</p>
<img src="//upload.wikimedia.org/math/7/a/d/7ad721c51e3fd880f548cbfa67e80832.png" class="[img]">


<p>马尔可夫过程通常称其为<strong>（时间）齐次</strong>，如果满足</p>
<img src="//upload.wikimedia.org/math/1/a/9/1a97955e98197a3ef3212d0cfba0a752.png" class="[img]">

<p>则称为<strong>（时间)非齐次</strong></p>
<h3 id="马尔可夫链">马尔可夫链</h3>
<p><strong>定义：</strong></p>
<p>马尔可夫链是随机变量<em>X1,X2,X3…</em>的一个数列。这些变量的范围，即他们所有可能取值的集合，被称为“状态空间”，而Xn的值则是在时间的状态。</p>
<p>已知随机变量Xn是n时刻的状态，如果Xn+1对于过去状态的条件概率分布仅是Xn的一个函数，则</p>
<p><code>P(Xn+1=x|X0,X1,X2,…,Xn)=P(Xn+1=x|Xn), x为过程中的某个状态。</code></p>
<p>时间和状态都是离散的Markov过程称之为Markov链，简记为马氏链。</p>
<h3 id="马氏链的转移概率(Transition_probability)">马氏链的转移概率(Transition probability)</h3>
<p>在经过一段较长时间的状态转移后，Markov过程会逐渐趋于稳定状态，且与初始状态无关，称为终极状态概率，或平衡状态概率。此时，记终极状态概率向量为X=[x1,x2,…,xn],则有X=Xp,0&lt;=Xi&lt;=1(I=1,2，…,n)，可用于预测Markov过程在未来出现什么趋势的重要信息。目前多应用于统计，生物，地理统计学，人力资源，因特网应用等多个领域。</p>
<h3 id="Slope_one_协同过滤算法">Slope one 协同过滤算法</h3>
<p><strong>Slope One</strong> 是一系列应用于 协同过滤的算法的统称。由于它的简洁高效，并拥有不输于其他复杂算法的精确度，因此用它来改进Markov链模型。</p>
<p>简要说明一下，<strong>Slope One</strong>和大多评分算法类似并不适用于类似电子商务中，买家只提供买或者不买这样的二进制数据情况。</p>
<p>Slope One的一系列基于Item-based协同过滤算法，其本质上都是线性回归函数(f(x) = x + c)，好处是减少<strong>过适（过拟合）</strong>。对比于一个项目评分和另一个项目评分的线性回归（f(x) = ax + c），它只需要一半的存储量。也符合<strong><em>奥卡姆剃刀</em></strong>的原理：<strong>若无必要，勿增实体</strong>。</p>
<img src="//upload.wikimedia.org/wikipedia/commons/c/cb/Simplicity_diagram.png">

<ol>
<li>User A 对 Item I 评分为1 对Item J 评分为1.5</li>
<li>User B 对 Item I 评分为2</li>
<li>你认为 User B 会给 Item J 打几分?</li>
<li>Slope One 的答案是：2.5 (1.5-1+2=2.5).</li>
</ol>
<p>对“n”个项目，想要实现 <strong>Slope One</strong>，只需要计算并存储“n”对评分间的平均差值和评价数目即可。</p>
<h3 id="协同马尔可夫链模型">协同马尔可夫链模型</h3>
<p>使用改变的<strong>Slope One</strong>对数据进行初次协同过滤处理，并在此基础上结合Markov链模型对用户行为进行分析预测。在一个推荐系统中，推荐的准确性很大程度上取决于其基于的数据库的大小，数据量小的情况下，经常会遇到冷启动的问题（Cold boot problem），区别于计算机系统的冷启动（Cold Start），它包括两个方面，一方面是新指用户没有行为数据，无法根据历史行为，预测其兴趣爱好，另一方面是新资源没有访问记录，没有数据分析，无法向用户推荐。</p>
<p>使用协同马尔可夫链模型，可以相对准确的预测用户的兴趣，有效的减少冷启动的问题。</p>
<p>以上是理论部分，简单介绍了协同马尔可夫模型的一些理论依据，下面重点讲解其在用户行为分析中的应用与分析。</p>
<h3 id="参考文献：">参考文献：</h3>
<ol>
<li><a href="http://wiki.mbalib.com/wiki/马尔可夫过程" target="_blank" rel="external">马尔可夫过程 - MBA智库百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/马尔可夫性质" target="_blank" rel="external">马尔可夫性质- 维基百科，自由的百科全书 - 维基百科- Wikipedia</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<h2 id="理论">理论</h2>
<h3 id="马尔可夫过程(Markov_Process)">马尔可夫过程(Markov Process)</h3>
<p>Markov过程是一个满足Markov性(无后效性)的随机过程。<br>具有马尔可夫性质的随机过程称为<strong>马尔可夫</strong>过程。[1]</p>
<p>最有名的Markov过程是Markov链，但还有其他的过程，如布朗运动，也是Markov过程。</p>
]]></summary>
    
      <category term="Math" scheme="http://beforeload.github.io/tags/Math/"/>
    
      <category term="Math" scheme="http://beforeload.github.io/categories/Math/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Inverted Index in Hadoop]]></title>
    <link href="http://beforeload.github.io/2013/04/18/invertedindex-in-hadoop/"/>
    <id>http://beforeload.github.io/2013/04/18/invertedindex-in-hadoop/</id>
    <published>2013-04-18T04:26:32.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="倒排索引">倒排索引</h2>
<h3 id="简介:">简介:</h3>
<p>倒排索引是文档检索系统中最常用的数据结构，被广泛地应用于全文搜索引擎。它主要是用来存储某个单词(或词组)在一个文档或一组文档中的存储位置的映射，即提供了一种根据内容来查找文档的方式。由于不是更具文档来确定文档包含的内容，而是进行想法的操作，因而成为倒排索引(Inverted Index)。[1]</p>
<a id="more"></a>

<p>我的理解就是找到单词出现的文档的名称，多数情况下为一个列表。</p>
<p>一个单词可能在不同的文件中出现，所以我们需要定义一个权重，表示单词(即搜索的内容)跟文档的<strong><em>相关度</em></strong>。相关度的衡量多数情况下用<strong><em>词频</em></strong>来表示。</p>
<p>更加复杂的算法TF-IDF(Term Frequency-Inverse Document Frequency)统计单词在多少个文档中出现，甚至考虑单词在文档中出现的位置(例如标题处反应这个单词的重要性)。</p>
<p>理论的东西到此结束，下面写一下倒排索引的设计与实现。</p>
<h3 id="问题分析：">问题分析：</h3>
<p>信息的关键： <strong>单词</strong>，<strong>文档URI</strong>及<strong>词频</strong></p>
<h3 id="设计：">设计：</h3>
<h4 id="Map过程：">Map过程：</h4>
<p>TextInputFormat: 输入文件处理 -&gt; 文本每行的偏移量及其内容<br><code>&lt;key, value&gt;</code> =&gt;  单词，文档URI和词频<br>两个值对应三个值，需要增加Combine过程进行词频统计。</p>
<p><strong><em>key</em></strong>： <strong>单词:URI</strong> (例如：MapReduce:1.txt)<br><strong><em>value</em></strong>：<strong>词频</strong>，相同单词词频组成列表传递给Combiner过程，实现的功能类似于WordCount      </p>
<h4 id="Combine过程：">Combine过程：</h4>
<p>Combine过程会把相同的key值对应的value值累加<br>Map过程得到的结果为    </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"MapRuduce:file01.txt"</span>  list<span class="function"><span class="params">(<span class="number">1</span>)</span>          =&gt;</span>     <span class="string">"MapReduce:file01.txt"</span>  <span class="number">1</span>    </div><div class="line"><span class="string">"is:file01.txt"</span>         list<span class="function"><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span>        =&gt;</span>     <span class="string">"is:file01.txt"</span>         <span class="number">2</span>    </div><div class="line"><span class="string">"powerful:file01.txt"</span>   list<span class="function"><span class="params">(<span class="number">1</span>)</span>          =&gt;</span>     <span class="string">"powerful:file01.txt"</span>   <span class="number">1</span>    </div><div class="line"><span class="string">"simple:file01.txt"</span>     list<span class="function"><span class="params">(<span class="number">1</span>)</span>          =&gt;</span>     <span class="string">"simple:file01.txt"</span>     <span class="number">1</span></div></pre></td></tr></table></figure>

<p><strong><em>key</em></strong>： <strong>单词</strong><br><strong><em>value</em></strong>: <strong>URI:词频</strong>(如：1.txt:1)</p>
<p><strong>好处</strong>：可以利用MapReduce框架默认的HashPartitioner类完成Shuffle过程。</p>
<h4 id="Reduce过程：">Reduce过程：</h4>
<p>Combiner过程就已经把相同的单词的所有记录发送给同一个Reducer进行处理，Reduce过程就变得很简单，只需要将相同的key和value值组合成倒排索引文件所需的格式即可，剩下的交给MapReducer框架自动完成。</p>
<h4 id="问题">问题</h4>
<ol>
<li>文件数目;</li>
<li>文件大小;</li>
<li>Reduce过程没有统计词频，有可能会造成词频未统计完全的单词。    </li>
</ol>
<p><strong>备注及解决办法：</strong></p>
<ol>
<li>单个文件不宜过大，具体值与默认HDFS块大小及相关配置有关；</li>
<li>重写InputFormat类将每个文件作为一个split；</li>
<li>执行两次MapReduce，第一次统计词频，第二次MapReduce用于生成倒排索引。</li>
</ol>
<h4 id="优化思路：">优化思路：</h4>
<ol>
<li>利用复合键值对等实现包含更多信息的倒排索引。</li>
</ol>
<p><strong><strong>附Java源码：</strong></strong></p>
<script src="https://gist.github.com/5443748.js?file=InvertedIndex.java"></script>

<p><strong>参考：</strong><br>[1]. 《实战Hadoop》</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="倒排索引">倒排索引</h2>
<h3 id="简介:">简介:</h3>
<p>倒排索引是文档检索系统中最常用的数据结构，被广泛地应用于全文搜索引擎。它主要是用来存储某个单词(或词组)在一个文档或一组文档中的存储位置的映射，即提供了一种根据内容来查找文档的方式。由于不是更具文档来确定文档包含的内容，而是进行想法的操作，因而成为倒排索引(Inverted Index)。[1]</p>
]]></summary>
    
      <category term="Java" scheme="http://beforeload.github.io/tags/Java/"/>
    
      <category term="Hadoop" scheme="http://beforeload.github.io/tags/Hadoop/"/>
    
      <category term="Algorithm" scheme="http://beforeload.github.io/tags/Algorithm/"/>
    
      <category term="Distributed Computing" scheme="http://beforeload.github.io/tags/Distributed-Computing/"/>
    
      <category term="Distributed Computing" scheme="http://beforeload.github.io/categories/Distributed-Computing/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MapReduce]]></title>
    <link href="http://beforeload.github.io/2013/04/13/analyze-mapreduce/"/>
    <id>http://beforeload.github.io/2013/04/13/analyze-mapreduce/</id>
    <published>2013-04-12T18:56:30.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<p>写在前面的话：看了N多MapReduce方面的理论知识，一直想写写自己对MapReduce的理解。</p>
<h2 id="MapReduce_编程模型">MapReduce 编程模型</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">map</span>:<span class="function"><span class="params">(K1, V1)</span> -&gt;</span> list(K2, V2)</div><div class="line"><span class="attribute">reduce</span>: <span class="function"><span class="params">(k2, list(V2))</span> -&gt;</span> list(K2, V2)</div></pre></td></tr></table></figure>

<p>简而言之就是 <strong><em> 输入-&gt; Mappers -&gt; 中间数据 -&gt; Reducer -&gt; 输出 </em></strong> 这样的一个过程，把输入<code>(key, value)</code>经过map和reduce函数转换成另一个或一批<code>(key, value)</code>对输出即可。</p>
<a id="more"></a>

<h3 id="Mapper">Mapper</h3>
<p>Map阶段，MapReduce对任务输入数据分割，切割成固定大小的片段(splits)，对每个split进一步分解成一批键值对<code>(K1, V1)</code>。然后Hadoop为每个split创建Map任务(Mapper)，执行自定义的<code>map()</code>。</p>
<p>将split中的<code>(K1, V1)</code>键值对输入，得到结果为<code>(K2, V2)</code>的中间结果。<code>map()</code>的功能到这里并没有结束，因为我们在reduce阶段需要的输入格式是<code>(K2, list(V2))</code>，所以还需要对Mapper输出结果<code>(K2, V2)</code>进行合并(Combine过程)，即将中间结果中有相同key值(如：K2)的多组<code>(key, value)</code>对合并成一对(形成<code>(K2, list(V2))</code>)。key值范围决定了这些元组分组，对应不同的Reduce任务(Reducer)。</p>
<p><em>Tips:</em></p>
<ol>
<li>一个类作为mapper，要继承MapReduceBase基类并实现Mapper接口；</li>
<li>Mapper接口负责数据处理阶段。采用形式为<code>Mapper&lt;K1, V1, K2, V2&gt;</code> Java泛型；</li>
<li>Mapper只有一个方法——map，用于处理一个单独的键/值对。</li>
</ol>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> map(K1 key, V1 value, OutputCollector&lt;K2, V2&gt; output, Reporter reporter)</div><div class="line">    <span class="keyword">throws</span> IOException</div></pre></td></tr></table></figure>

<h3 id="Reducer">Reducer</h3>
<p>Reduce阶段，数据整合，排序。然后调用自定义函数<code>reduce()</code>，输入<code>(K2, list(V2))</code>，得到键值对<code>&lt;K3, V3&gt;</code>输出到HDFS上。</p>
<p><em>Tips:</em></p>
<ol>
<li>Reducers数目在mapred-site.xml中决定，属性是<code>mapred.reduce.tasks</code>，默认值是 1，<code>job.setNumReduceTasks()</code>方法也可以用于设置，<strong>这是一个很重要的值</strong>；</li>
<li>reducer的实现首先必须在MapReduce基类上扩展，允许配置和清理。它必须实现Reducer接口实现<strong>reduce</strong>方法: </li>
</ol>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> reduce(K2 key, Iterator&lt;V2&gt; values, OutputCollector&lt;K3, V3&gt; output, </div><div class="line">        Reporter reporter) <span class="keyword">throws</span> IOException</div></pre></td></tr></table></figure>

<ol>
<li><code>reduce()</code>函数最后生成的列表<code>(K3, V3)</code>可能为空；</li>
<li>map阶段和reduce阶段中间还有partitioner的工作：负责将mapper的结果输出给不同的reducer。</li>
</ol>
<h3 id="Hadoop的MapReduce">Hadoop的MapReduce</h3>
<p>Hadoop框架的核心是Map和Reduce操作，但不仅仅如此，还包括：</p>
<p><strong><em> data spliting(数据分割), shuffling(洗牌), Partitioning(分组), Combining(合并) </em></strong></p>
<p>以及各种格式的输入输出数据。</p>
<h3 id="Shuffler">Shuffler</h3>
<p>Mapper的按key值分为R份(R即为上面说到的Reducers的数目)，划分时通常采用hash函数，如<code>Hash(key) mod R</code>。目的是保证某一范围内的key一定由某个Reducer来处理。</p>
<p><em>Tips:</em></p>
<ol>
<li>洗牌之后相同的key对应的键值对放入相同的Reducer，不同的键也可以放入相同的Reducer。具体放入的位置由Partitioner决定。</li>
</ol>
<h3 id="Partitioner:重定向Mapper输出">Partitioner:重定向Mapper输出</h3>
<p>并不是数据排序好就是最好的。利用并行计算，不能仅仅靠一个reducer，那样就不是“云”而是“雨点”。当多个reducer一起使用时，默认的做法是对键值对进行hash来确定reducer。</p>
<p><em>Tips:</em></p>
<ol>
<li>Hadoop通过HashPartitioner类强制执行Partitioner策略。但HashPartitioner有时会出错；</li>
<li>量身定制partitioner，只需要实现<code>configure()</code>和<code>getPartition()</code>两个函数，前者将Hadoop对作业的配置应用在patitioner上，后者返回一个0到reduce任务数之间的整数，指向键/值对将要发送到的reducer。</li>
</ol>
<h3 id="Combiner:_本地reduce">Combiner: 本地reduce</h3>
<p>合并Mapper输出，即将多个key相同的<code>&lt;key, value&gt;</code>合并成一对。Combine过程和Reduce过程类似，很多情况下可以直接使用reduce函数，但Combiner过程是Mapper的一部分，在map函数后执行。</p>
<p><em>Tips：</em></p>
<ol>
<li>Hadoop并不保证对一个Mapper执行多少次Combine过程，所以我们应该做到无论Combine过程执行多少次，得到结果都一样；</li>
<li>中间结果的读取，JobTracker介入，负责通知中间文件的位置；</li>
<li>Mapper输出结果不在HDFS上而在本地磁盘上，出于时效性考虑，任务结束后删除，而HDFS的备份机制会造成性能损失，没有必要。</li>
</ol>
<h3 id="讨论：">讨论：</h3>
<p>很多时候Rudecer产生的R个结果不是我们真正需要的最终结果，此时会把R个结果作为另一个计算的输入，开始另一个MapReduce任务，即任务管道。</p>
<h3 id="总结:">总结:</h3>
<p>MapReduce的集群行为(即MapReduce运行在大规模集群上的过程)，要完成一个并行计算，需要<em>_</em>任务调度与执行，本地计算，Shuffle，合并Mapper输出，读取中间结果，任务管道等一系列环节共同支撑计算的过程。</p>
]]></content>
    <summary type="html"><![CDATA[<p>写在前面的话：看了N多MapReduce方面的理论知识，一直想写写自己对MapReduce的理解。</p>
<h2 id="MapReduce_编程模型">MapReduce 编程模型</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">map</span>:<span class="function"><span class="params">(K1, V1)</span> -&gt;</span> list(K2, V2)</div><div class="line"><span class="attribute">reduce</span>: <span class="function"><span class="params">(k2, list(V2))</span> -&gt;</span> list(K2, V2)</div></pre></td></tr></table></figure>

<p>简而言之就是 <strong><em> 输入-&gt; Mappers -&gt; 中间数据 -&gt; Reducer -&gt; 输出 </em></strong> 这样的一个过程，把输入<code>(key, value)</code>经过map和reduce函数转换成另一个或一批<code>(key, value)</code>对输出即可。</p>
]]></summary>
    
      <category term="Hadoop" scheme="http://beforeload.github.io/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://beforeload.github.io/tags/MapReduce/"/>
    
      <category term="Distributed Computing" scheme="http://beforeload.github.io/categories/Distributed-Computing/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解深度优先和广度优先]]></title>
    <link href="http://beforeload.github.io/2013/04/09/DFS-and-BFS/"/>
    <id>http://beforeload.github.io/2013/04/09/DFS-and-BFS/</id>
    <published>2013-04-09T05:14:20.000Z</published>
    <updated>2013-04-12T18:49:30.000Z</updated>
    <content type="html"><![CDATA[<h4 id="问题：">问题：</h4>
<p>迷宫, 1为墙壁， 0为可以走的路， 只能横着走和竖着走，求解左上角到右下角的路线。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int maze[<span class="link_label">5</span>][<span class="link_reference">5</span>] = {</div><div class="line"><span class="code">    0, 1, 0, 0, 0,</span></div><div class="line"><span class="code">    0, 1, 0, 1, 0,</span></div><div class="line"><span class="code">    0, 0, 0, 0, 0,</span></div><div class="line"><span class="code">    0, 0, 0, 1, 0,</span></div><div class="line">};</div></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="思路：">思路：</h3>
<p><strong>解法一：</strong></p>
<p>深度优先搜索(DFS, Depth First Search):每次搜索完各个方向相邻的点之后，取其中一个相邻的点走下去，一直走到无路可走了再退回来(回溯)，取另一个相邻的点再走下去。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">将起点标记为已走过并压栈；</div><div class="line"><span class="keyword">while</span> (栈非空) {</div><div class="line">    从栈顶弹出一个点P；</div><div class="line">    <span class="keyword">if</span> (p这个点是终点) {</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    沿右、下、左、上四个方向探索相邻的点;</div><div class="line">    <span class="keyword">if</span> (和p相邻的点有路可走，并且还没走过) {</div><div class="line">        将相邻的点标记为已走过并压栈，它的前趋就是p点;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">if</span> (p点是终点) {</div><div class="line">    打印p点的坐标；</div><div class="line">    <span class="keyword">while</span> (p点有前趋) {</div><div class="line">        p点 = p点的前趋;</div><div class="line">        打印p点的坐标;</div><div class="line">    }</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    没有路线可以到达终点;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong><em>附源码如下：</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="comment">#define MAX_ROW 5</span></div><div class="line"><span class="comment">#define MAX_COL 5</span></div><div class="line"></div><div class="line">struct point {</div><div class="line">    int row, col;</div><div class="line">} stack[512];</div><div class="line"></div><div class="line">int top = 0;</div><div class="line"></div><div class="line">void push(struct point p)</div><div class="line">{</div><div class="line">	stack[top++] = p;</div><div class="line">}</div><div class="line"></div><div class="line">struct point pop(void)</div><div class="line">{</div><div class="line">	return stack[--top];</div><div class="line">}</div><div class="line"></div><div class="line">int is_empty(void)</div><div class="line">{</div><div class="line">	return top == 0;</div><div class="line">}</div><div class="line"></div><div class="line">int maze[MAX_ROW][MAX_COL] = {</div><div class="line">	0, 1, 0, 0, 0,</div><div class="line">	0, 1, 0, 1, 0,</div><div class="line">	0, 0, 0, 0, 0,</div><div class="line">	0, 1, 1, 1, 0,</div><div class="line">	0, 0, 0, 1, 0,</div><div class="line">};</div><div class="line"></div><div class="line">void print_maze(void)</div><div class="line">{</div><div class="line">	int i, j;</div><div class="line">	for (i = 0; i &lt; MAX_ROW; i++) {</div><div class="line">		for (j = 0; j &lt; MAX_COL; j++) {</div><div class="line">			printf(<span class="string">"%d "</span>, maze[i][j]);</div><div class="line">		}</div><div class="line">		putchar('\n');</div><div class="line">	}</div><div class="line">	printf(<span class="string">"************\n"</span>);</div><div class="line">}</div><div class="line"></div><div class="line">struct point predecessor[MAX_ROW][MAX_COL] = {</div><div class="line">	{ {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},</div><div class="line">	{ {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},</div><div class="line">	{ {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},</div><div class="line">	{ {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},</div><div class="line">	{ {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},</div><div class="line">};</div><div class="line"></div><div class="line">void visit(int row, int col, struct point pre)</div><div class="line">{</div><div class="line">	struct point visit_point = {</div><div class="line">		row, col</div><div class="line">	};</div><div class="line">	maze[row][col] = 2;</div><div class="line">	predecessor[row][col] = pre;</div><div class="line">	push(visit_point);</div><div class="line">}</div><div class="line"></div><div class="line">int main(void)</div><div class="line">{</div><div class="line">	struct point p = {</div><div class="line">		0, 0</div><div class="line">	};</div><div class="line">	maze[p.row][p.col] = 2;</div><div class="line">	push(p);</div><div class="line"></div><div class="line">	while (!is_empty()) {</div><div class="line">		p = pop();</div><div class="line">		if (p.row == MAX_ROW - 1 && p.col == MAX_COL - 1) {</div><div class="line">			break;</div><div class="line">		}</div><div class="line">		if (p.col + 1 &lt; MAX_COL && maze[p.row][p.col + 1] == 0) {</div><div class="line">			visit(p.row, p.col + 1, p);</div><div class="line">		}</div><div class="line">		if (p.row + 1 &lt; MAX_ROW && maze[p.row + 1][p.col] == 0) {</div><div class="line">			visit(p.row + 1, p.col, p);</div><div class="line">		}</div><div class="line">		if (p.col - 1 &gt;= 0 && maze[p.row][p.col - 1] == 0) {</div><div class="line">			visit(p.row, p.col - 1, p);</div><div class="line">		}</div><div class="line">		if (p.row - 1 &gt;= 0 && maze[p.row - 1][p.col] == 0) {</div><div class="line">			visit(p.row - 1, p.col, p);</div><div class="line">		}</div><div class="line">		print_maze();</div><div class="line">	}</div><div class="line">	if (p.col == MAX_COL - 1 && p.row == MAX_ROW - 1) {</div><div class="line">		printf(<span class="string">"(%d, %d)\n"</span>, p.row, p.col);</div><div class="line">		while (predecessor[p.row][p.col].row != -1) {</div><div class="line">			p = predecessor[p.row][p.col];</div><div class="line">			printf(<span class="string">"(%d, %d)\n"</span>, p.row, p.col);</div><div class="line">		}</div><div class="line">	} else {</div><div class="line">		printf(<span class="string">"No path!\n"</span>);</div><div class="line">	}</div><div class="line">	return 0;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>DFS 优化：</strong></p>
<p>代码没有什么难懂的地方，不过有很多可以优化的地方，例如在predecessor这个数据结构上，浪费了太多的存储空间，可以做以下优化：</p>
<ol>
<li>重新定义predecessor存储方式</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct point predecessor[<span class="link_label">MAX_ROW</span>][<span class="link_reference">MAX_COL</span>] = { 0 };</div></pre></td></tr></table></figure>

<p>所有的值定义为0,前趋点为上点，则将他赋值为1，前趋点为下点，则赋值为-1，前趋点为左点，则赋值为2,前趋点为右点，则赋值为-2；通过定义四个不同的值区分前趋点，减少了存储空间，相应的函数也要对应修改即可。</p>
<ol>
<li>用递归取代predecessor数据结构</li>
</ol>
<p><strong>解法二：</strong><br>广度优先搜索(BFS, Breadth First Search):<br>BFS沿各个方向上同时展开搜索，每个可以走通的方向轮流往前走一步。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">将起点标记为已经走过的队列</div><div class="line"><span class="keyword">while</span> (队列非空) {</div><div class="line">    出队一个点p;</div><div class="line">    <span class="keyword">if</span> (p为终点) {</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    否则沿右下左上四个方向探索相邻的点</div><div class="line">    <span class="keyword">if</span> (和p相邻的点有路走，且没有走过) {</div><div class="line">        将相邻的点标记为已经走过并入队列，他的前趋就是刚出队的p点;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (p点是终点) {</div><div class="line">        打印p点的坐标;</div><div class="line">        <span class="keyword">while</span> (p点有前趋) {</div><div class="line">            p点 = p 点的前趋;</div><div class="line">            打印 p 点的坐标;</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        没有到达终点的路线;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>BFS相比较于DFS，BFS可以找到从起点到终点的最短路径。</p>
<p><strong><em>附源码如下:</em></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="comment">#define MAX_ROW 5</span></div><div class="line"><span class="comment">#define MAX_COL 5</span></div><div class="line"></div><div class="line">struct point {</div><div class="line">	int row, col, predecessor;</div><div class="line">} queue[512];</div><div class="line"></div><div class="line">int head = 0, tail = 0;</div><div class="line"></div><div class="line">void enqueue(struct point p)</div><div class="line">{</div><div class="line">	queue[tail++] = p;</div><div class="line">}</div><div class="line"></div><div class="line">struct point dequeue(void)</div><div class="line">{</div><div class="line">	return queue[head++];</div><div class="line">}</div><div class="line"></div><div class="line">int is_empty(void)</div><div class="line">{</div><div class="line">	return head == tail;</div><div class="line">}</div><div class="line"></div><div class="line">int maze[MAX_ROW][MAX_COL] = {</div><div class="line">	0, 1, 0, 0, 0,</div><div class="line">	0, 1, 0, 1, 0,</div><div class="line">	0, 0, 0, 0, 0,</div><div class="line">	0, 1, 1, 1, 0,</div><div class="line">	0, 0, 0, 1, 0,</div><div class="line">};</div><div class="line"></div><div class="line">void print_maze(void)</div><div class="line">{</div><div class="line">	int i, j;</div><div class="line">	for (i = 0; i &lt; MAX_ROW; i++) {</div><div class="line">		for (j = 0; j &lt; MAX_COL; j++) {</div><div class="line">			printf(<span class="string">"%d "</span>, maze[i][j]);</div><div class="line">		}</div><div class="line">		putchar('\n');</div><div class="line">	}</div><div class="line">	printf(<span class="string">"************\n"</span>);</div><div class="line">}</div><div class="line"></div><div class="line">void visit(int row, int col)</div><div class="line">{</div><div class="line">	struct point visit_point = {</div><div class="line">		row, col, head - 1</div><div class="line">	};</div><div class="line">	maze[row][col] = 2;</div><div class="line">	enqueue(visit_point);</div><div class="line">}</div><div class="line"></div><div class="line">int main(void)</div><div class="line">{</div><div class="line">	struct point p = {</div><div class="line">		0, 0, -1</div><div class="line">	};</div><div class="line">	maze[p.row][p.col] = 2;</div><div class="line">	enqueue(p);</div><div class="line"></div><div class="line">	while (!is_empty()) {</div><div class="line">		p = dequeue();</div><div class="line">		if (p.row == MAX_ROW - 1 && p.col == MAX_COL - 1) {</div><div class="line">			break;</div><div class="line">		}</div><div class="line">		if (p.row + 1 &lt; MAX_ROW && maze[p.row + 1][p.col] == 0) {</div><div class="line">			visit(p.row + 1, p.col);</div><div class="line">		}</div><div class="line">		if (p.col + 1 &lt; MAX_COL && maze[p.row][p.col + 1] == 0) {</div><div class="line">			visit(p.row, p.col + 1);</div><div class="line">		}</div><div class="line">		if (p.col - 1 &gt;= 0 && maze[p.row][p.col - 1] == 0) {</div><div class="line">			visit(p.row, p.col - 1);</div><div class="line">		}</div><div class="line">		if (p.row - 1 &gt;= 0 && maze[p.row - 1][p.col] == 0) {</div><div class="line">			visit(p.row - 1, p.col);</div><div class="line">		}</div><div class="line">		print_maze();</div><div class="line">	}</div><div class="line">	if (p.row == MAX_ROW - 1 && p.col == MAX_COL - 1) {</div><div class="line">		printf(<span class="string">"(%d, %d)\n"</span>, p.row, p.col);</div><div class="line">		while (p.predecessor != -1) {</div><div class="line">			p = queue[p.predecessor];</div><div class="line">			printf(<span class="string">"(%d, %d)\n"</span>, p.row, p.col);</div><div class="line">		}</div><div class="line">	} else {</div><div class="line">		printf(<span class="string">"No path!\n"</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="参考：">参考：</h4>
<ol>
<li>《Linux C编程一站式学习》<a href="http://learn.akae.cn/media/ch12.html" target="_blank" rel="external">栈与队列</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<h4 id="问题：">问题：</h4>
<p>迷宫, 1为墙壁， 0为可以走的路， 只能横着走和竖着走，求解左上角到右下角的路线。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int maze[<span class="link_label">5</span>][<span class="link_reference">5</span>] = {</div><div class="line"><span class="code">    0, 1, 0, 0, 0,</span></div><div class="line"><span class="code">    0, 1, 0, 1, 0,</span></div><div class="line"><span class="code">    0, 0, 0, 0, 0,</span></div><div class="line"><span class="code">    0, 0, 0, 1, 0,</span></div><div class="line">};</div></pre></td></tr></table></figure>

]]></summary>
    
      <category term="C" scheme="http://beforeload.github.io/tags/C/"/>
    
      <category term="Data Structure" scheme="http://beforeload.github.io/tags/Data-Structure/"/>
    
      <category term="Algorithm" scheme="http://beforeload.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://beforeload.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop 的 Java API 使用案例]]></title>
    <link href="http://beforeload.github.io/2013/04/06/hdfs-java-api/"/>
    <id>http://beforeload.github.io/2013/04/06/hdfs-java-api/</id>
    <published>2013-04-06T07:14:42.000Z</published>
    <updated>2014-12-16T08:56:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="案例">案例</h3>
<ol>
<li>上传本地文件到 HDFS</li>
<li>创建 HDFS 文件</li>
<li>重命名 HDFS 文件</li>
<li>删除 HDFS 上的文件</li>
<li>查看 HDFS 文件的最后修改时间</li>
<li>查看某个 HDFS 文件是否存在</li>
<li>查找某个文件在 HDFS 集群的位置</li>
<li>获取 HDFS 集群上所有节点的名称</li>
</ol>
<a id="more"></a>

<h4 id="上传本地文件到_HDFS">上传本地文件到 HDFS</h4>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span>(String src, String dst, String config) <span class="keyword">throws</span> IOException{</div><div class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">    conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">    FileSystem hdfs = FileSystem.get(conf);</div><div class="line">    Path srcPath = <span class="keyword">new</span> Path(src);</div><div class="line">    Path dstPath = <span class="keyword">new</span> Path(dst);</div><div class="line">    hdfs.copyFromLocalFile(srcPath, dstPath);</div><div class="line">    System.out.println(<span class="string">"Upload to "</span> + conf.get(<span class="string">"fs.default.name"</span>));</div><div class="line">    </div><div class="line">    FileStatus files[] = hdfs.listStatus(dstPath);</div><div class="line">    <span class="keyword">for</span> (FileStatus file : files) {</div><div class="line">        System.out.println(file.getPath());</div><div class="line">    }</div><div class="line">    hdfs.close();</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="创建_HDFS_文件">创建 HDFS 文件</h4>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span>(String dst, String config) <span class="keyword">throws</span> IOException{</div><div class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">    conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">    String content = <span class="string">"Hello World,beforeload"</span>;</div><div class="line">    <span class="keyword">byte</span>[] buff = content.getBytes();</div><div class="line">    FileSystem hdfs = FileSystem.get(conf);</div><div class="line">    Path dfsPath = <span class="keyword">new</span> Path(dst);</div><div class="line">    FSDataOutputStream os = hdfs.create(dfsPath);</div><div class="line">    os.write(buff,<span class="number">0</span>,buff.length);</div><div class="line">    os.write(content.getBytes(<span class="string">"UTF-8"</span>));</div><div class="line">    os.close();</div><div class="line">    hdfs.close();</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="重命名_HDFS_文件">重命名 HDFS 文件</h4>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rename</span>(String oldName, String newName, String config)</div><div class="line">        <span class="keyword">throws</span> IOException {</div><div class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">    conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">    FileSystem hdfs = FileSystem.get(conf);</div><div class="line">    Path oldPath = <span class="keyword">new</span> Path(oldName);</div><div class="line">    Path newPath = <span class="keyword">new</span> Path(newName);</div><div class="line">    <span class="keyword">boolean</span> isRename = hdfs.rename(oldPath, newPath);</div><div class="line">}</div></pre></td></tr></table></figure>


<h4 id="删除_HDFS_上的文件">删除 HDFS 上的文件</h4>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFile</span>(String path, String config) <span class="keyword">throws</span> IOException {</div><div class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">    conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">    FileSystem hdfs = FileSystem.get(conf);</div><div class="line">    Path deletePath = <span class="keyword">new</span> Path(path);</div><div class="line">    <span class="keyword">boolean</span> isDeleted = hdfs.delete(deletePath, <span class="keyword">false</span>);</div><div class="line">    <span class="comment">// 递归删除</span></div><div class="line">    <span class="comment">// boolean isDelete = hdfs.delete(deletePath, true);</span></div><div class="line">    System.out.println(<span class="string">"delete? "</span>+ isDeleted);</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="查看_HDFS_文件的最后修改时间">查看 HDFS 文件的最后修改时间</h4>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTime</span>(String path, String config) <span class="keyword">throws</span> IOException{</div><div class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">    conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">    FileSystem hdfs = FileSystem.get(conf);</div><div class="line">    Path filePath = <span class="keyword">new</span> Path(path);</div><div class="line">    FileStatus fileStatus = hdfs.getFileStatus(filePath);</div><div class="line">    <span class="keyword">long</span> modifyTime = fileStatus.getModificationTime();</div><div class="line">    System.out.println(<span class="string">"Modification time is:"</span> + modifyTime);</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="查看某个_HDFS_文件是否存在">查看某个 HDFS 文件是否存在</h4>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isExist</span>(String path, String config) <span class="keyword">throws</span> IOException {</div><div class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">    conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">    FileSystem hdfs = FileSystem.get(conf);</div><div class="line">    <span class="keyword">boolean</span> isExist = hdfs.exists(<span class="keyword">new</span> Path(path));</div><div class="line">    System.out.println(<span class="string">"Exist?"</span>+ isExist);</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="查找某个文件在_HDFS_集群的位置">查找某个文件在 HDFS 集群的位置</h4>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileBlockLocation</span>(String path, String config)</div><div class="line">        <span class="keyword">throws</span> IOException {</div><div class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">    conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">    FileSystem hdfs = FileSystem.get(conf);</div><div class="line">    Path filePath = <span class="keyword">new</span> Path(path);</div><div class="line">    FileStatus fileStatus = hdfs.getFileStatus(filePath);</div><div class="line">    BlockLocation[] blockLocations = hdfs.getFileBlockLocations(fileStatus,</div><div class="line">            <span class="number">0</span>, fileStatus.getLen());</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blockLocations.length; i++) {</div><div class="line">        String[] hosts = blockLocations[i].getHosts();</div><div class="line">        System.out.println(<span class="string">"block"</span> + i + <span class="string">"location:"</span> + hosts[i]);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="获取_HDFS_集群上所有节点的名称">获取 HDFS 集群上所有节点的名称</h4>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getHostName</span>(String config) <span class="keyword">throws</span> IOException {</div><div class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">    conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">    FileSystem fs = FileSystem.get(conf);</div><div class="line">    DistributedFileSystem hdfs = (DistributedFileSystem) fs;</div><div class="line">    DatanodeInfo[] dataNodeStats = hdfs.getDataNodeStats();</div><div class="line">    String[] names = <span class="keyword">new</span> String[dataNodeStats.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataNodeStats.length; i++) {</div><div class="line">        names[i] = dataNodeStats[i].getHostName();</div><div class="line">        System.out.println(<span class="string">"node "</span> + i + <span class="string">" name "</span> + names[i]);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="问题">问题</h3>
<ol>
<li>“Wrong FS expected: file:///“</li>
</ol>
<p>这个问题其实严格意义上并不属于API调用方面的问题，具体问题出现的原因不得而知，不过在查阅资料一番后还是得出了问题的解决方法。</p>
<ul>
<li>stackoverflow上给出<a href="http://stackoverflow.com/questions/7969519/what-is-the-loading-order-of-the-configuration-files-in-hadoop/7995180#7995180" target="_blank" rel="external">问题</a>的解决方法，不过经过尝试后，也只能发出感叹：”It doesn’t work!” </li>
<li>幸好在<a href="http://www.opensourceconnections.com/2013/03/24/hdfs-debugging-wrong-fs-expected-file-exception" target="_blank" rel="external">Doug的博客</a>上给出了解答，通过添加一行代码即可</li>
</ul>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conf.addResource(<span class="keyword">new</span> Path(<span class="string">"/root/hadoop-0.20.2/conf/core-site.xml"</span>));</div></pre></td></tr></table></figure>

<h3 id="讨论">讨论</h3>
<p><strong><em>附源码如下：</em></strong></p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.BlockLocation;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataOutputStream;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileStatus;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.hdfs.DistributedFileSystem;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.hdfs.protocol.DatanodeInfo;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> IOException {</div><div class="line">		String src, dst1, config, dst2, oldName, newName;</div><div class="line">		src = <span class="string">"/root/word.txt"</span>;</div><div class="line">		dst1 = <span class="string">"/"</span>;</div><div class="line">		config = <span class="string">"/root/hadoop-0.20.2/conf/core-site.xml"</span>;</div><div class="line">		<span class="comment">// copyFile(src, dst1, config);</span></div><div class="line"></div><div class="line">		dst2 = <span class="string">"/test.txt"</span>;</div><div class="line">		<span class="comment">// createFile(dst2, config);</span></div><div class="line"></div><div class="line">		oldName = dst2;</div><div class="line">		newName = <span class="string">"/test1.txt"</span>;</div><div class="line">		<span class="comment">// rename(oldName, newName, config);</span></div><div class="line"></div><div class="line">		<span class="comment">// deleteFile(dst2, config);</span></div><div class="line">		<span class="comment">// getTime(dst1, config);</span></div><div class="line"></div><div class="line">		<span class="comment">// isExist(dst2, config);</span></div><div class="line">		<span class="comment">// isExist(dst1, config);</span></div><div class="line"></div><div class="line">		<span class="comment">// getFileBlockLocation(dst2, config);</span></div><div class="line"></div><div class="line">		getHostName(config);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span>(String src, String dst, String config)</div><div class="line">			<span class="keyword">throws</span> IOException {</div><div class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">		conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">		FileSystem hdfs = FileSystem.get(conf);</div><div class="line">		Path srcPath = <span class="keyword">new</span> Path(src);</div><div class="line">		Path dstPath = <span class="keyword">new</span> Path(dst);</div><div class="line">		hdfs.copyFromLocalFile(srcPath, dstPath);</div><div class="line">		System.out.println(<span class="string">"Upload to "</span> + conf.get(<span class="string">"fs.default.name"</span>));</div><div class="line"></div><div class="line">		FileStatus files[] = hdfs.listStatus(dstPath);</div><div class="line">		<span class="keyword">for</span> (FileStatus file : files) {</div><div class="line">			System.out.println(file.getPath());</div><div class="line">		}</div><div class="line">		hdfs.close();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span>(String dst, String config) <span class="keyword">throws</span> IOException {</div><div class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">		conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">		String content = <span class="string">"Hello World,beforeload"</span>;</div><div class="line">		<span class="keyword">byte</span>[] buff = content.getBytes();</div><div class="line">		FileSystem hdfs = FileSystem.get(conf);</div><div class="line">		Path dfsPath = <span class="keyword">new</span> Path(dst);</div><div class="line">		FSDataOutputStream os = hdfs.create(dfsPath);</div><div class="line">		os.write(buff, <span class="number">0</span>, buff.length);</div><div class="line">		os.write(content.getBytes(<span class="string">"UTF-8"</span>));</div><div class="line">		os.close();</div><div class="line">		hdfs.close();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rename</span>(String oldName, String newName, String config)</div><div class="line">			<span class="keyword">throws</span> IOException {</div><div class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">		conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">		FileSystem hdfs = FileSystem.get(conf);</div><div class="line">		Path oldPath = <span class="keyword">new</span> Path(oldName);</div><div class="line">		Path newPath = <span class="keyword">new</span> Path(newName);</div><div class="line">		<span class="keyword">boolean</span> isRename = hdfs.rename(oldPath, newPath);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFile</span>(String path, String config)</div><div class="line">			<span class="keyword">throws</span> IOException {</div><div class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">		conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">		FileSystem hdfs = FileSystem.get(conf);</div><div class="line">		Path deletePath = <span class="keyword">new</span> Path(path);</div><div class="line">		<span class="keyword">boolean</span> isDeleted = hdfs.delete(deletePath, <span class="keyword">false</span>);</div><div class="line">		<span class="comment">// 递归删除</span></div><div class="line">		<span class="comment">// boolean isDelete = hdfs.delete(deletePath, true);</span></div><div class="line">		System.out.println(<span class="string">"delete? "</span> + isDeleted);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTime</span>(String path, String config) <span class="keyword">throws</span> IOException {</div><div class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">		conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">		FileSystem hdfs = FileSystem.get(conf);</div><div class="line">		Path filePath = <span class="keyword">new</span> Path(path);</div><div class="line">		FileStatus fileStatus = hdfs.getFileStatus(filePath);</div><div class="line">		<span class="keyword">long</span> modifyTime = fileStatus.getModificationTime();</div><div class="line">		System.out.println(<span class="string">"Modification time is:"</span> + modifyTime);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isExist</span>(String path, String config) <span class="keyword">throws</span> IOException {</div><div class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">		conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">		FileSystem hdfs = FileSystem.get(conf);</div><div class="line">		<span class="keyword">boolean</span> isExist = hdfs.exists(<span class="keyword">new</span> Path(path));</div><div class="line">		System.out.println(<span class="string">"Exist?"</span> + isExist);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileBlockLocation</span>(String path, String config)</div><div class="line">			<span class="keyword">throws</span> IOException {</div><div class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">		conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">		FileSystem hdfs = FileSystem.get(conf);</div><div class="line">		Path filePath = <span class="keyword">new</span> Path(path);</div><div class="line">		FileStatus fileStatus = hdfs.getFileStatus(filePath);</div><div class="line">		BlockLocation[] blockLocations = hdfs.getFileBlockLocations(fileStatus,</div><div class="line">				<span class="number">0</span>, fileStatus.getLen());</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blockLocations.length; i++) {</div><div class="line">			String[] hosts = blockLocations[i].getHosts();</div><div class="line">			System.out.println(<span class="string">"block"</span> + i + <span class="string">"location:"</span> + hosts[i]);</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getHostName</span>(String config) <span class="keyword">throws</span> IOException {</div><div class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">		conf.addResource(<span class="keyword">new</span> Path(config));</div><div class="line">		FileSystem fs = FileSystem.get(conf);</div><div class="line">		DistributedFileSystem hdfs = (DistributedFileSystem) fs;</div><div class="line">		DatanodeInfo[] dataNodeStats = hdfs.getDataNodeStats();</div><div class="line">		String[] names = <span class="keyword">new</span> String[dataNodeStats.length];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataNodeStats.length; i++) {</div><div class="line">			names[i] = dataNodeStats[i].getHostName();</div><div class="line">			System.out.println(<span class="string">"node "</span> + i + <span class="string">" name "</span> + names[i]);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="参考书籍：">参考书籍：</h4>
<ol>
<li>《Hadoop实战》—— “Hadoop in Action”</li>
<li>《实战Hadoop》—— “开启通向云计算的捷径”</li>
<li><a href="http://hadoop.apache.org/core/docs/current/api/org/apache/hadoop/fs/package-summary.html" target="_blank" rel="external">Hadoop Java API 官方文档</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<h3 id="案例">案例</h3>
<ol>
<li>上传本地文件到 HDFS</li>
<li>创建 HDFS 文件</li>
<li>重命名 HDFS 文件</li>
<li>删除 HDFS 上的文件</li>
<li>查看 HDFS 文件的最后修改时间</li>
<li>查看某个 HDFS 文件是否存在</li>
<li>查找某个文件在 HDFS 集群的位置</li>
<li>获取 HDFS 集群上所有节点的名称</li>
</ol>
]]></summary>
    
      <category term="Java" scheme="http://beforeload.github.io/tags/Java/"/>
    
      <category term="Hadoop" scheme="http://beforeload.github.io/tags/Hadoop/"/>
    
      <category term="Distributed Computing" scheme="http://beforeload.github.io/tags/Distributed-Computing/"/>
    
      <category term="Distributed Computing" scheme="http://beforeload.github.io/categories/Distributed-Computing/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[k-th Order Statistic]]></title>
    <link href="http://beforeload.github.io/2013/04/05/k-th-order-statistic/"/>
    <id>http://beforeload.github.io/2013/04/05/k-th-order-statistic/</id>
    <published>2013-04-05T12:12:32.000Z</published>
    <updated>2014-07-20T12:08:09.000Z</updated>
    <content type="html"><![CDATA[<h3 id="问题描述:">问题描述:</h3>
<h6 id="问题来源:_线性查找">问题来源: <a href="http://learn.akae.cn/media/ch11s05.html" target="_blank" rel="external">线性查找</a></h6>
<ol>
<li>实现一个算法，在一组随机排列的数中找出最小的一个。你能想到的最直观的算法一定是Θ(n)的，想想有没有比Θ(n)更快的算法？</li>
<li>在一组随机排列的数中找出第二小的，这个问题比上一个稍复杂，你能不能想出Θ(n)的算法？</li>
<li>进一步泛化，在一组随机排列的数中找出第k小的，这个元素称为<code>k-th Order Statistic</code>。能想到的最直观的算法肯定是先把这些数排序然后取第k个，时间复杂度和排序算法相同，可以是Θ(nlgn)。这个问题虽然比前两个问题复杂，但它也有平均情况下时间复杂度是Θ(n)的算法</li>
</ol>
<a id="more"></a>

<h3 id="求解及算法：">求解及算法：</h3>
<p>求一组数中最小值，对于数组而言是一个很easy且常见的问题。<br>解决算法也很容易:</p>
<pre><code><span class="keyword">int</span> minimum(<span class="keyword">int</span> arr[])
{
    <span class="keyword">int</span> j,temp;
    temp = arr[<span class="number">0</span>];

    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; N; j++) {
        <span class="keyword">if</span>(temp &gt; arr[j]){
            swap(&amp;temp,&amp;arr[j]);
        }
    }
    <span class="keyword">return</span> temp;
}
</code></pre><p>算法复杂度为Θ(n),且只需要遍历一次即可得出结果；</p>
<ol>
<li>在数组中求解第二小值也不是一件难事，只要想清楚求解的思路和步骤，问题便可迎刃而解。<br>当然算法可能性多种多样，我所采用的方法简单粗暴：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/** 第二小的数 */</span></div><div class="line"><span class="keyword">int</span> second_min(<span class="keyword">int</span> arr[])</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> min, smin, i;</div><div class="line">        min = smin = arr[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) {</div><div class="line">        <span class="keyword">if</span> (arr[i] &lt;= min) {</div><div class="line">            smin = min;</div><div class="line">            min = arr[i];</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> smin;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在每次找到更小的数字时，把当前的数字赋值给第二小的数字，算法复杂度同样是Θ(n),且只需遍历一次即可得出结果。</p>
<ol>
<li>对于求<code>k-th Order Statistic</code>元素，常规的解法是先排序，后根据排出的顺序，得到第k小的值。时间复杂度等同与排序的时间复杂度。当然，我们不需要完全排出顺序也能得到结果，学过<code>quick sort</code>之后，根据<code>pivot</code>元素的位置与k值比较，稍作修改快排算法即可得出解法。<br>求解算法如下：</li>
</ol>
<pre><code>
int partition(int start, int end)
{
    int pivot, mid, i;
    pivot = arr[start];
    mid = start;
    for (i = start + 1; i &lt;= end; i++) {
        if (arr[i] &lt; pivot) {
            mid++;
            swap(&amp;arr[i], &amp;arr[mid]);
        }
    }
    swap(&amp;arr[mid], &amp;arr[start]);
    return mid;
}

int order_statistic(int start, int end, int k)
{
    int i;
    if (start &lt; end) {
        i = partition(start, end);
        if (k == i) {
            return i;
        } else if (k &gt; i) {
            order_statistic(i + 1, end, k);
        } else {
            order_statistic(start, i - 1, k);
        }
    }
}
</code></pre>

<p>算法复杂度等同与快排是Θ(nlgn)，平均复杂度为Θ(n)。</p>
<p>附上完整C语言代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#define N 10
int arr[N] = { 3, 4, 1, 3, 5, 6, 7, 9, 1, 2 };

int partition(int start, int end)
{
    int pivot, mid, i;
    pivot = arr[start];
    mid = start;
    for (i = start + 1; i &lt;= end; i++) {
        if (arr[i] &lt; pivot) {
            mid++;
            swap(&amp;arr[i], &amp;arr[mid]);
        }
    }
    swap(&amp;arr[mid], &amp;arr[start]);
    return mid;
}

int order_statistic(int start, int end, int k)
{
    int i;
    if (start &lt; end) {
        i = partition(start, end);
        if (k == i) {
            return i;
        } else if (k &gt; i) {
            order_statistic(i + 1, end, k);
        } else {
            order_statistic(start, i - 1, k);
        }
    }
}

int swap(int *a, int *b)
{
    int temp;
    temp = *b;
    *b = *a;
    *a = temp;
}

int main(int argc, const char *argv[])
{
    int i, k = 3, result;
    result = order_statistic(0, N - 1, k);
    for (i = 0; i &lt; N; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    printf("The %d-th Order Statistic is %d.\n", k + 1, arr[result]);
    return 0;
}
</code></pre>

<h3 id="讨论">讨论</h3>
<hr>
]]></content>
    <summary type="html"><![CDATA[<h3 id="问题描述:">问题描述:</h3>
<h6 id="问题来源:_线性查找">问题来源: <a href="http://learn.akae.cn/media/ch11s05.html" target="_blank" rel="external">线性查找</a></h6>
<ol>
<li>实现一个算法，在一组随机排列的数中找出最小的一个。你能想到的最直观的算法一定是Θ(n)的，想想有没有比Θ(n)更快的算法？</li>
<li>在一组随机排列的数中找出第二小的，这个问题比上一个稍复杂，你能不能想出Θ(n)的算法？</li>
<li>进一步泛化，在一组随机排列的数中找出第k小的，这个元素称为<code>k-th Order Statistic</code>。能想到的最直观的算法肯定是先把这些数排序然后取第k个，时间复杂度和排序算法相同，可以是Θ(nlgn)。这个问题虽然比前两个问题复杂，但它也有平均情况下时间复杂度是Θ(n)的算法</li>
</ol>
]]></summary>
    
      <category term="C" scheme="http://beforeload.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="http://beforeload.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://beforeload.github.io/categories/Algorithm/"/>
    
  </entry>
  
</feed>
